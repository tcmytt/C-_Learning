C# nền Console Application

1. C# là gì?
C# là một ngôn ngữ lập trình thuần hướng đối tượng được phát triển bởi Microsoft.
Được xây dựng dựa trên nền tảng của 2 ngôn ngữ lập trình mạnh nhất đó là C++ và Java. 
C# với sự hỗ trợ mạnh mẽ của .NET Framework giúp cho việc tạo một ứng dụng Windows Forms hay WPF (Windows Presentation Foundation), . . . trở nên rất dễ dàng.

2.Cấu trúc lệnh cơ bản trong C# Console Application

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cau_Truc_Lenh_Co_Ban
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}


- using <tên thư viện>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

- Namespace : 
namespace <tên namespace>{
    // Các thành phần bên trong namespace bao gồm các lớp, enum, delegate hoặc các
    // namespace con
 }

VD: namespace Cau_Truc_Lenh_Co_Ban{
    public class Action { }
    public delegate void Art();
    namespace Sub_Namespace { }
}
- comment
Ctrl + K + C: đóng comment đoạn code 
Ctrl + K + U: để mở đoạn comment

3. Nhập xuất cơ bản trong C# Console Application
- Console.Write();
Cú pháp: Console.Write(<giá trị cần in ra màn hình>);
Ý nghĩa: In giá trị ra màn hình console. Giá trị này có thể là 1 ký tự, 1 chuỗi, một giá trị có thể chuyển về kiểu chuỗi

- Console.WriteLine();
Cú pháp: Console.WriteLine(<giá trị cần in ra màn hình>);
Ý nghĩa: In giá trị ra màn hình xong nó sẽ tự động đưa con trỏ xuống dòng.
C1: Console.WriteLine(“K team”)  
C2: Console.Write (“K team \n”) 
C3: Environment.NewLine

int a = 5; 
Console.Write("a =  “ + a); // Kết quả màn hình là: a = 5
In ra giá trị của biến: Console.Write("{0} {1} {2} {...}", <giá trị 0>, <giá trị 1>, <giá trị 2>, <giá trị n>);
Console.Write("a = {0}", a); // In ra màn hình giá trị "a = 5".

- Console.Read();
VD: Console.WriteLine(Console.Read());
Đọc 1 ký tự từ bàn phím và trả về kiểu số nguyên (sẽ được trình bày chi tiết ở bài KIỂU DỮ LIỆU TRONG C#) là mã ASCII
Chú ý: lệnh này không đọc được các phím chức năng như Ctrl, Shift, Alt, Caps Lock, Tab, . . .

- Console.ReadLine();
VD: Console.WriteLine(Console.ReadLine());
Ý nghĩa: Đọc dữ liệu từ bàn phím cho đến khi gặp ký tự xuống dòng thì dừng (Nói cách khác là đọc cho đến khi mình nhấn enter thì dừng) và giá trị đọc được luôn là một chuỗi.

- Console.ReadKey(<tham số kiểu bool>)
Lệnh này cũng dùng để đọc một ký tự từ bàn phím nhưng trả về kiểu ConsoleKeyInfo (là một kiểu dữ liệu có cấu trúc được định nghĩa sẵn để chứa những ký tự của bàn phím bao gồm các phím chức năng).

4. Kiểu dữ liệu 
Kiểu dữ liệu giá trị (value): bool, byte, char, decimal, double, enum, float, int, long, sbyte, short, struct, uint, ulong, ushort.
Kiểu dữ liệu tham chiếu (reference): object, dynamic, string và tất cả các kiểu dữ liệu do người dùng định nghĩa.
Giá trị của kiểu char sẽ nằm trong dấu ‘ ’ (nháy đơn).
Giá trị của kiểu string sẽ nằm trong dấu “ ” (nháy kép).
Giá trị của biến kiểu float phải có chữ F hoặc f làm hậu tố.
Giá trị của biến kiểu decimal phải có chữ m hoặc M làm hậu tố.
Trừ kiểu string, tất cả kiểu dữ liệu trên đều không được có giá trị null

strSoNguyen = Console.ReadLine(); // Đọc dữ liệu nhập vào từ bàn phím (dữ liệu này ở dạng chuỗi) sau đó gán giá trị vào biến strSoNguyen
SoNguyen = Int32.Parse(strSoNguyen); // Ép kiểu dữ liệu vừa nhập vào (dạng chuỗi) sang dạng số rồi gán giá trị vào biến SoNguyen
KetQua = (SoNguyen % 2 == 0) ? "so chan" : "so le"; // Sử dụng toán tử 3 ngôi để kiểm tra số chẵn lẻ

5. Hằng trong C#
const <kiểu dữ liệu> <tên biến> = <giá trị hằng>;
Kiểu liệt kê(ENUM) là tập hợp các tên hằng có giá trị không thay đổi.
- (<kiểu dữ liệu>) <biến cần ép kiểu>
int i = 300; // 300 có mã nhị phân là 100101100
byte b = (byte)i; 
double d = 2 / 3; // kết quả ra 0 vì 2 và 3 đều là số nguyên nên thực hiện 2 chia lấy phần nguyên với 3 được 0
double k = (double)2 / 3; // Ép kiểu số 2 từ kiểu nguyên sang kiểu số thực. Như vậy kết quả phép chia sẽ ra số thực
double t = 1.0 * 2 / 3; 

- <kiểu dữ liệu>.Parse(<dữ liệu cần chuyển đổi>); Chuyển đổi một chuỗi sang một kiểu dữ liệu cơ bản tương ứng.
string stringValue = "10";
int intValue = int.Parse(stringValue); // Chuyển chuỗi stringValue sang kiểu int và lưu giá trị vào biến intValue - Kết quả intValue = 10
double HowKteam = double.Parse("10.9"); // Chuyển chuỗi giá trị hằng "10.9" sang kiểu int và lưu giá trị vào biến HowKteam - Kết quả HowKteam = 10.9

- <kiểu dữ liệu>.TryParse(<dữ liệu cần chuyển đổi>, out <biến chứa kết quả>); Chuyển một chuỗi sang một kiểu dữ liệu cơ bản tương ứng.
Phương thức sẽ trả về true nếu chuyển kiểu thành công và giá trị kết quả chuyển kiểu sẽ lưu vào <biến chứa kết quả>. Ngược lại sẽ trả về false và <biến chứa kết quả> sẽ mang giá trị 0.
bool isSuccess; // Biến kiểm tra việc ép kiểu có thành công hay không
string Data1 = "10", Data2 = "Kteam"; // Dữ liệu cần ép kiểu
isSuccess = int.TryParse(Data1, out Result);

-Ngoài TryParse() ra thì vẫn có một cách ép kiểu không báo lỗi chương trình. Đó là sử dụng toán tử as:
Trong bài TOÁN TỬ TRONG C# chúng ta có giới thiệu toán tử as dùng để “Ép kiểu mà không gây ra lỗi. Nếu ép kiểu không thành công sẽ trả về null”.

- Convert()
gõ “Convert.” (lưu ý dấu chấm liền sau Convert) Visual Studio sẽ hiển thị ra tất cả các phương thức có trong lớp Convert. 
Giờ bạn chỉ việc lựa chọn phương thức muốn sử dụng là được.
VD: String str = Convert.ToBase64String(B); 
Các trường hợp tham số truyền vào sai định dạng hoặc vượt quá giới hạn thì chương trình sẽ báo lỗi như phương thức Parse().

6. Kiểu dữ liệu Object trong C#
- Thuộc kiểu dữ liệu tham chiếu, Mọi kiểu dữ liệu đều được kế thừa từ System.Object

- Boxing là quá trình chuyển dữ liệu từ kiểu dữ liệu giá trị sang kiểu dữ liệu tham chiếu.
VD:    int Value = 109; 
    object ObjectValue = Value; 

- Unboxing là quá trình ngược lại với boxing, tức là đưa dữ liệu từ kiểu dữ liệu tham chiếu về kiểu dữ liệu giá trị.
VD: int NewValue = (int)ObjectValue; 

- Từ khóa var trong C# :  
Bắt buộc phải gán giá trị ngay khi khởi tạo biến và không thể khởi tạo giá trị null cho biến var.
var chỉ là từ khóa dùng để khai báo biến không phải là một kiểu dữ liệu.
VD: 
var varLong = 109;
var varString = null; // lỗi

7. Từ khóa Dynamic trong C#
Khai báo : dynamic <tên biến>;
Từ khóa dynamic là từ khóa dùng để khai báo kiểu dynamic. Kiểu dynamic là một khái niệm mới được đưa vào trong C# 4.0.
Các đối tượng thuộc kiểu dynamic sẽ không xác định được kiểu cho đến khi chương trình được thực thi. 
Tức là trình biên dịch sẽ bỏ qua tất cả lỗi về cú pháp, việc kiểm tra này sẽ thực hiện khi chương trình thực thi.
Có thể ép kiểu qua lại với các kiểu dữ liệu khác một cách bình thường 

VD1:
// Khai báo biến StringValue kiểu dynamic và khởi tạo giá trị là một chuỗi kiểu string
dynamic StringValue = "HowKteam";
/* 
* Chúng ta biết rằng kiểu chuỗi không hỗ trợ toán tử ++
* Nhưng câu lệnh StringValue++ vẫn không báo lỗi là do ở thời điểm hiện tại trình biên dịch vẫn chưa xác định kiểu dữ liệu cho biến StringValue
* Khi chạy chương trình thì lúc này C# mới phát hiện biến StringValue là kiểu string và không thể thực hiện toán tử ++ lúc đó sẽ xuất hiện lỗi
*/
StringValue++;

VD2:
// Khai báo 2 biến Name và Mission kiểu string và khởi tạo giá trị.
string Name = "HowKteam ";
string Mission = "Free Education";
/* 
 * Thực hiện gán 1 biến kiểu string cho biến kiểu dynamic bằng cách ép kiểu ngầm định (implicit)
 * Sau phép gán này thì biến DynamicValue chứa giá trị là "Free Education" nhưng kiểu dữ liệu của nó vẫn chưa được xác định.
*/
dynamic DynamicName = Name;

// Thực hiện cộng chuỗi và in ra màn hình bình thường
Console.WriteLine("Mission of " + DynamicName + " is " + Mission);


Phân biệt object, var và dynamic
- object là kiểu dữ liệu , var và dynamic là từ khoá
- object và dynamic sử dụng để làm kiểu trả về hoặc tham số cho hàm;
- object và dynamic có khả năng ép kiểu qua lại với các kiểu dữ liệu khác 
- var xác định ngay khai báo, dynamic lúc thực thi

8. goto
Vòng lặp For
Vòng lặp While
Vòng lặp Do While
Vòng lặp Foreach

Vòng lặp goto
cấu trúc : 
    label:
    goto label;

static void Main(string[] args){
    int a = 1;
    if (a == 2)
    {
        // dịch chuyển tới vị trí label a_Is_2
        goto a_Is_2;
    }
    Console.WriteLine("A == 1");
    a_Is_2:
    Console.WriteLine("A == 2");
    Console.ReadKey();
}
 
9.Cấu trúc của hàm cơ bản trong C#
[Từ khóa 1] [Từ khóa 2] [Từ khóa n]  <Kiểu dữ liệu trả về> <Tên hàm>([Parameter]){ }
- [Từ khóa 1], [Từ khóa 2], [Từ khóa n] là các từ khóa như: public, static, read only … và có thể không điền.
- Kiểu dữ liệu trả về như: từ khóa void, hay mọi kiểu dữ liệu như int, long, bool, SinhVien…
- Parameter là tham số truyền vào để sử dụng nội bộ trong hàm. Cấu trúc khởi tạo như một biến bình thường. Có thể không điền.
- Hàm chỉ được khai báo bên trong class.

10. Biến
class Program {
        static int value = 5;
        static void Main(string[] args)  {
            Console.WriteLine(value); // 5
            value = 10;
            PrintSomeThing();
            Console.ReadKey();
        }
        static void PrintSomeThing() {           
            Console.WriteLine(value); // 10
        }
    }

11. Từ khóa ref và out trong C#
- Từ khóa ref
ref hơi giống & trong c++ truyền vào tác dụng thay đổi giá trị gốc khi được gọi hàm
Từ khóa ref phải có trước tên parametter của hàm và trước tên biến truyền vào khi gọi hàm sử dụng.
Truyền parameter có từ khóa ref bắt buộc phải là một biến (không thể truyền vào một hằng vì hằng là giá trị không thay đổi).
Có thể có một hoặc nhiều parameter với từ khóa ref trong lời khai báo hàm.
Biến truyền vào có từ khóa ref thì phải được khởi tạo giá trị trước khi truyền vào.
Hàm sử dụng sẽ thao tác trực tiếp với vùng nhớ của các parameter trên RAM. Cho nên kết thúc lời gọi hàm giá trị các parameter sẽ bị thay đổi.
VD:static void Main(string[] args){
           int value = 5;
           Console.WriteLine("Value before increase: {0}", value);
           IncreaseValue(ref value);
           Console.WriteLine("Value after increase: {0}", value);
           Console.ReadKey();
        }
        static void IncreaseValue(ref int value){
            value++;
        }

- Từ khóa out
Từ khóa out cũng tương tự từ khóa ref. Đó là:
Vùng nhớ của các parameter sẽ được hàm sử dụng thao tác trực tiếp, dẫn đến khi kết thúc lời gọi hàm giá trị của các parametter có thể bị thay đổi.
 Phải có từ khóa out trước tên parameter của hàm và trước tên biến truyền vào khi gọi hàm sử dụng.

Nhưng có một sự khác biệt đó là:
 Biến truyền vào có từ khóa out sẽ không cần khởi tạo giá trị ban đầu.
 Parameter đó chỉ như một thùng chứa kết quả trả về khi kết thúc gọi hàm.
 Đồng thời parameter đó phải được khởi tạo ngay bên trong lời gọi hàm.

 12. Mảng
- Mảng 1 chiều :
 <kiểu dữ liệu>[] <tên mảng> = new <kiểu dữ liệu>[] { <giá trị 1>, …, <giá trị n> };
 VD:
 string[] Kteam = new string[3];
 int[] IntArray = { 3, 9, 10 };
 string[] Kteam = new string[] { "HowKteam", "Free Education" };

- Mảng 2 chiều :
<kiểu dữ liệu> [ , ] <tên mảng>;
VD:
string[,] Kteam = new string[2, 3]; // số dòng là 2 và số cột là 3.
int[,] IntArray = 
{ 
    {1, 2}, 
    {3, 4}, 
    {5, 6} 
};
string[,] Kteam = new string[,] 
{
{ "HowKteam", "Free Education" },
{ “HowKteam.com”, “Share to be better” }
}; 

Phương thức :
.length(); .Clone();

- Mảng jagged trong C# : 
Không giống như mảng 2 chiều, mảng jagged không cho phép cấp phát cùng lúc số dòng và số cột 
mà phải cấp phát số dòng trước sau đó ứng với mỗi dòng ta cấp phát số cột theo ý muốn.
<kiểu dữ liệu> [ ][ ] <tên mảng>;
VD:  int [][] JaggedArray = new int[3][];
     JaggedArray[0] = new int[3];
     JaggedArray[1] = new int[9];
     JaggedArray[2] = new int[10];

int[][] JArray ={
    new int[] {1, 2, 3},
    new int[] {3, 4, 5, 6, 7, 8, 9}
};
Sử dụng <tên mảng>[i][j] thay vì <tên mảng>[i, j].

- Lớp Array trong C# :
Lớp Array trong C# là lớp cơ sở cho mọi mảng, một mảng bất kỳ đều được kế thừa từ lớp này
Array.Sort(<tên mảng>)
Array.Reverse(<tên mảng>)
Array.IndexOf(<tên mảng>, <phần tử cần tìm>)

13. Vòng lặp foreach trong lập trình C#
Một số đặc trưng của foreach:
Foreach không duyệt mảng hoặc tập hợp thông qua chỉ số phần tử như cấu trúc lặp for.
Foreach duyệt tuần tự các phần tử trong mảng hoặc tập hợp.
Foreach chỉ dùng để duyệt mảng hoặc tập hợp ngoài ra không thể làm gì khác.

foreach (<kiểu dữ liệu> <tên biến tạm> in <tên mảng hoặc tập hợp>)
{
  // Code xử lý        
}

Trong C#, có những danh sách, tập hợp mà ta không thể truy xuất đến các phần tử của nó thông qua chỉ số phần tử được 
Trong trường hợp như vậy, để duyệt các danh sách, tập hợp có tính chất như trên thì foreach là lựa chọn tốt nhất.