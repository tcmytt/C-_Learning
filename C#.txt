C# nền Console Application, Học từ 2 trang web : HowKteam và XuanThuLab

1. C# là gì?
C# là một ngôn ngữ lập trình thuần hướng đối tượng được phát triển bởi Microsoft.
Được xây dựng dựa trên nền tảng của 2 ngôn ngữ lập trình mạnh nhất đó là C++ và Java. 
C# với sự hỗ trợ mạnh mẽ của .NET Framework giúp cho việc tạo một ứng dụng Windows Forms hay WPF (Windows Presentation Foundation), . . . trở nên rất dễ dàng.
dotnet -- version
dotnet run
dotnet publish
dotnet new console
dotnet new console --use-program-main

2.Cấu trúc lệnh cơ bản trong C# Console Application

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cau_Truc_Lenh_Co_Ban
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}


- using <tên thư viện>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

- Namespace : 
namespace <tên namespace>{
    // Các thành phần bên trong namespace bao gồm các lớp, enum, delegate hoặc các
    // namespace con
 }

VD: namespace Cau_Truc_Lenh_Co_Ban{
    public class Action { }
    public delegate void Art();
    namespace Sub_Namespace { }
}
- comment
Ctrl + K + C: đóng comment đoạn code 
Ctrl + K + U: để mở đoạn comment

3. Nhập xuất cơ bản trong C# Console Application
- Console.Write();
Cú pháp: Console.Write(<giá trị cần in ra màn hình>);
Ý nghĩa: In giá trị ra màn hình console. Giá trị này có thể là 1 ký tự, 1 chuỗi, một giá trị có thể chuyển về kiểu chuỗi

- Console.WriteLine();
Cú pháp: Console.WriteLine(<giá trị cần in ra màn hình>);
Ý nghĩa: In giá trị ra màn hình xong nó sẽ tự động đưa con trỏ xuống dòng.
C1: Console.WriteLine(“K team”)  
C2: Console.Write (“K team \n”) 
C3: Environment.NewLine

int a = 5; 
Console.Write("a =  “ + a); // Kết quả màn hình là: a = 5
In ra giá trị của biến: Console.Write("{0} {1} {2} {...}", <giá trị 0>, <giá trị 1>, <giá trị 2>, <giá trị n>);
Console.Write("a = {0}", a); // In ra màn hình giá trị "a = 5".

- Console.Read();
VD: Console.WriteLine(Console.Read());
Đọc 1 ký tự từ bàn phím và trả về kiểu số nguyên (sẽ được trình bày chi tiết ở bài KIỂU DỮ LIỆU TRONG C#) là mã ASCII
Chú ý: lệnh này không đọc được các phím chức năng như Ctrl, Shift, Alt, Caps Lock, Tab, . . .

- Console.ReadLine();
VD: Console.WriteLine(Console.ReadLine());
Ý nghĩa: Đọc dữ liệu từ bàn phím cho đến khi gặp ký tự xuống dòng thì dừng (Nói cách khác là đọc cho đến khi mình nhấn enter thì dừng) và giá trị đọc được luôn là một chuỗi.

- Console.ReadKey(<tham số kiểu bool>)
Lệnh này cũng dùng để đọc một ký tự từ bàn phím nhưng trả về kiểu ConsoleKeyInfo (là một kiểu dữ liệu có cấu trúc được định nghĩa sẵn để chứa những ký tự của bàn phím bao gồm các phím chức năng).

4. Kiểu dữ liệu 
Kiểu dữ liệu giá trị (value): bool, byte, char, decimal, double, enum, float, int, long, sbyte, short, struct, uint, ulong, ushort.
Kiểu dữ liệu tham chiếu (reference): object, dynamic, string và tất cả các kiểu dữ liệu do người dùng định nghĩa.
Giá trị của kiểu char sẽ nằm trong dấu ‘ ’ (nháy đơn).
Giá trị của kiểu string sẽ nằm trong dấu “ ” (nháy kép).
Giá trị của biến kiểu float phải có chữ F hoặc f làm hậu tố.
Giá trị của biến kiểu decimal phải có chữ m hoặc M làm hậu tố.
Trừ kiểu string, tất cả kiểu dữ liệu trên đều không được có giá trị null

strSoNguyen = Console.ReadLine(); // Đọc dữ liệu nhập vào từ bàn phím (dữ liệu này ở dạng chuỗi) sau đó gán giá trị vào biến strSoNguyen
SoNguyen = Int32.Parse(strSoNguyen); // Ép kiểu dữ liệu vừa nhập vào (dạng chuỗi) sang dạng số rồi gán giá trị vào biến SoNguyen
KetQua = (SoNguyen % 2 == 0) ? "so chan" : "so le"; // Sử dụng toán tử 3 ngôi để kiểm tra số chẵn lẻ

5. Hằng trong C#
const <kiểu dữ liệu> <tên biến> = <giá trị hằng>;
Kiểu liệt kê(ENUM) là tập hợp các tên hằng có giá trị không thay đổi.
- (<kiểu dữ liệu>) <biến cần ép kiểu>
int i = 300; // 300 có mã nhị phân là 100101100
byte b = (byte)i; 
double d = 2 / 3; // kết quả ra 0 vì 2 và 3 đều là số nguyên nên thực hiện 2 chia lấy phần nguyên với 3 được 0
double k = (double)2 / 3; // Ép kiểu số 2 từ kiểu nguyên sang kiểu số thực. Như vậy kết quả phép chia sẽ ra số thực
double t = 1.0 * 2 / 3; 

- <kiểu dữ liệu>.Parse(<dữ liệu cần chuyển đổi>); Chuyển đổi một chuỗi sang một kiểu dữ liệu cơ bản tương ứng.
string stringValue = "10";
int intValue = int.Parse(stringValue); // Chuyển chuỗi stringValue sang kiểu int và lưu giá trị vào biến intValue - Kết quả intValue = 10
double HowKteam = double.Parse("10.9"); // Chuyển chuỗi giá trị hằng "10.9" sang kiểu int và lưu giá trị vào biến HowKteam - Kết quả HowKteam = 10.9

- <kiểu dữ liệu>.TryParse(<dữ liệu cần chuyển đổi>, out <biến chứa kết quả>); Chuyển một chuỗi sang một kiểu dữ liệu cơ bản tương ứng.
Phương thức sẽ trả về true nếu chuyển kiểu thành công và giá trị kết quả chuyển kiểu sẽ lưu vào <biến chứa kết quả>. Ngược lại sẽ trả về false và <biến chứa kết quả> sẽ mang giá trị 0.
bool isSuccess; // Biến kiểm tra việc ép kiểu có thành công hay không
string Data1 = "10", Data2 = "Kteam"; // Dữ liệu cần ép kiểu
isSuccess = int.TryParse(Data1, out Result);

-Ngoài TryParse() ra thì vẫn có một cách ép kiểu không báo lỗi chương trình. Đó là sử dụng toán tử as:
Trong bài TOÁN TỬ TRONG C# chúng ta có giới thiệu toán tử as dùng để “Ép kiểu mà không gây ra lỗi. Nếu ép kiểu không thành công sẽ trả về null”.

- Convert()
gõ “Convert.” (lưu ý dấu chấm liền sau Convert) Visual Studio sẽ hiển thị ra tất cả các phương thức có trong lớp Convert. 
Giờ bạn chỉ việc lựa chọn phương thức muốn sử dụng là được.
VD: String str = Convert.ToBase64String(B); 
Các trường hợp tham số truyền vào sai định dạng hoặc vượt quá giới hạn thì chương trình sẽ báo lỗi như phương thức Parse().

6. Kiểu dữ liệu Object trong C#
- Thuộc kiểu dữ liệu tham chiếu, Mọi kiểu dữ liệu đều được kế thừa từ System.Object

- Boxing là quá trình chuyển dữ liệu từ kiểu dữ liệu giá trị sang kiểu dữ liệu tham chiếu.
VD:    int Value = 109; 
    object ObjectValue = Value; 

- Unboxing là quá trình ngược lại với boxing, tức là đưa dữ liệu từ kiểu dữ liệu tham chiếu về kiểu dữ liệu giá trị.
VD: int NewValue = (int)ObjectValue; 

- Từ khóa var trong C# :  
Bắt buộc phải gán giá trị ngay khi khởi tạo biến và không thể khởi tạo giá trị null cho biến var.
var chỉ là từ khóa dùng để khai báo biến không phải là một kiểu dữ liệu.
VD: 
var varLong = 109;
var varString = null; // lỗi

7. Từ khóa Dynamic trong C#
Khai báo : dynamic <tên biến>;
Từ khóa dynamic là từ khóa dùng để khai báo kiểu dynamic. Kiểu dynamic là một khái niệm mới được đưa vào trong C# 4.0.
Các đối tượng thuộc kiểu dynamic sẽ không xác định được kiểu cho đến khi chương trình được thực thi. 
Tức là trình biên dịch sẽ bỏ qua tất cả lỗi về cú pháp, việc kiểm tra này sẽ thực hiện khi chương trình thực thi.
Có thể ép kiểu qua lại với các kiểu dữ liệu khác một cách bình thường 

VD1:
// Khai báo biến StringValue kiểu dynamic và khởi tạo giá trị là một chuỗi kiểu string
dynamic StringValue = "HowKteam";
/* 
* Chúng ta biết rằng kiểu chuỗi không hỗ trợ toán tử ++
* Nhưng câu lệnh StringValue++ vẫn không báo lỗi là do ở thời điểm hiện tại trình biên dịch vẫn chưa xác định kiểu dữ liệu cho biến StringValue
* Khi chạy chương trình thì lúc này C# mới phát hiện biến StringValue là kiểu string và không thể thực hiện toán tử ++ lúc đó sẽ xuất hiện lỗi
*/
StringValue++;

VD2:
// Khai báo 2 biến Name và Mission kiểu string và khởi tạo giá trị.
string Name = "HowKteam ";
string Mission = "Free Education";
/* 
 * Thực hiện gán 1 biến kiểu string cho biến kiểu dynamic bằng cách ép kiểu ngầm định (implicit)
 * Sau phép gán này thì biến DynamicValue chứa giá trị là "Free Education" nhưng kiểu dữ liệu của nó vẫn chưa được xác định.
*/
dynamic DynamicName = Name;

// Thực hiện cộng chuỗi và in ra màn hình bình thường
Console.WriteLine("Mission of " + DynamicName + " is " + Mission);


Phân biệt object, var và dynamic
- object là kiểu dữ liệu , var và dynamic là từ khoá
- object và dynamic sử dụng để làm kiểu trả về hoặc tham số cho hàm;
- object và dynamic có khả năng ép kiểu qua lại với các kiểu dữ liệu khác 
- var xác định ngay khai báo, dynamic lúc thực thi

8. goto
Vòng lặp For
Vòng lặp While
Vòng lặp Do While
Vòng lặp Foreach

Vòng lặp goto
cấu trúc : 
    label:
    goto label;

static void Main(string[] args){
    int a = 1;
    if (a == 2)
    {
        // dịch chuyển tới vị trí label a_Is_2
        goto a_Is_2;
    }
    Console.WriteLine("A == 1");
    a_Is_2:
    Console.WriteLine("A == 2");
    Console.ReadKey();
}
 
9.Cấu trúc của hàm cơ bản trong C#
[Từ khóa 1] [Từ khóa 2] [Từ khóa n]  <Kiểu dữ liệu trả về> <Tên hàm>([Parameter]){ }
- [Từ khóa 1], [Từ khóa 2], [Từ khóa n] là các từ khóa như: public, static, read only … và có thể không điền.
- Kiểu dữ liệu trả về như: từ khóa void, hay mọi kiểu dữ liệu như int, long, bool, SinhVien…
- Parameter là tham số truyền vào để sử dụng nội bộ trong hàm. Cấu trúc khởi tạo như một biến bình thường. Có thể không điền.
- Hàm chỉ được khai báo bên trong class.

10. Biến
class Program {
        static int value = 5;
        static void Main(string[] args)  {
            Console.WriteLine(value); // 5
            value = 10;
            PrintSomeThing();
            Console.ReadKey();
        }
        static void PrintSomeThing() {           
            Console.WriteLine(value); // 10
        }
    }

11. Từ khóa ref và out trong C#
- Từ khóa ref
ref hơi giống & trong c++ truyền vào tác dụng thay đổi giá trị gốc khi được gọi hàm
Từ khóa ref phải có trước tên parametter của hàm và trước tên biến truyền vào khi gọi hàm sử dụng.
Truyền parameter có từ khóa ref bắt buộc phải là một biến (không thể truyền vào một hằng vì hằng là giá trị không thay đổi).
Có thể có một hoặc nhiều parameter với từ khóa ref trong lời khai báo hàm.
Biến truyền vào có từ khóa ref thì phải được khởi tạo giá trị trước khi truyền vào.
Hàm sử dụng sẽ thao tác trực tiếp với vùng nhớ của các parameter trên RAM. Cho nên kết thúc lời gọi hàm giá trị các parameter sẽ bị thay đổi.
VD:static void Main(string[] args){
           int value = 5;
           Console.WriteLine("Value before increase: {0}", value);
           IncreaseValue(ref value);
           Console.WriteLine("Value after increase: {0}", value);
           Console.ReadKey();
        }
        static void IncreaseValue(ref int value){
            value++;
        }

- Từ khóa out
Từ khóa out cũng tương tự từ khóa ref. Đó là:
Vùng nhớ của các parameter sẽ được hàm sử dụng thao tác trực tiếp, dẫn đến khi kết thúc lời gọi hàm giá trị của các parametter có thể bị thay đổi.
 Phải có từ khóa out trước tên parameter của hàm và trước tên biến truyền vào khi gọi hàm sử dụng.

Nhưng có một sự khác biệt đó là:
 Biến truyền vào có từ khóa out sẽ không cần khởi tạo giá trị ban đầu.
 Parameter đó chỉ như một thùng chứa kết quả trả về khi kết thúc gọi hàm.
 Đồng thời parameter đó phải được khởi tạo ngay bên trong lời gọi hàm.

 12. Mảng
- Mảng 1 chiều :
 <kiểu dữ liệu>[] <tên mảng> = new <kiểu dữ liệu>[] { <giá trị 1>, …, <giá trị n> };
 VD:
 string[] Kteam = new string[3];
 int[] IntArray = { 3, 9, 10 };
 string[] Kteam = new string[] { "HowKteam", "Free Education" };

- Mảng 2 chiều :
<kiểu dữ liệu> [ , ] <tên mảng>;
VD:
string[,] Kteam = new string[2, 3]; // số dòng là 2 và số cột là 3.
int[,] IntArray = 
{ 
    {1, 2}, 
    {3, 4}, 
    {5, 6} 
};
string[,] Kteam = new string[,] 
{
{ "HowKteam", "Free Education" },
{ “HowKteam.com”, “Share to be better” }
}; 

Phương thức :
.length(); .Clone();

- Mảng jagged trong C# : 
Không giống như mảng 2 chiều, mảng jagged không cho phép cấp phát cùng lúc số dòng và số cột 
mà phải cấp phát số dòng trước sau đó ứng với mỗi dòng ta cấp phát số cột theo ý muốn.
<kiểu dữ liệu> [ ][ ] <tên mảng>;
VD:  int [][] JaggedArray = new int[3][];
     JaggedArray[0] = new int[3];
     JaggedArray[1] = new int[9];
     JaggedArray[2] = new int[10];

int[][] JArray ={
    new int[] {1, 2, 3},
    new int[] {3, 4, 5, 6, 7, 8, 9}
};
Sử dụng <tên mảng>[i][j] thay vì <tên mảng>[i, j].

- Lớp Array trong C# :
Lớp Array trong C# là lớp cơ sở cho mọi mảng, một mảng bất kỳ đều được kế thừa từ lớp này
Array.Sort(<tên mảng>)
Array.Reverse(<tên mảng>)
Array.IndexOf(<tên mảng>, <phần tử cần tìm>)

13. Vòng lặp foreach trong lập trình C#
Một số đặc trưng của foreach:
Foreach không duyệt mảng hoặc tập hợp thông qua chỉ số phần tử như cấu trúc lặp for.
Foreach duyệt tuần tự các phần tử trong mảng hoặc tập hợp.
Foreach chỉ dùng để duyệt mảng hoặc tập hợp ngoài ra không thể làm gì khác.

foreach (<kiểu dữ liệu> <tên biến tạm> in <tên mảng hoặc tập hợp>)
{
  // Code xử lý        
}

Trong C#, có những danh sách, tập hợp mà ta không thể truy xuất đến các phần tử của nó thông qua chỉ số phần tử được 
Trong trường hợp như vậy, để duyệt các danh sách, tập hợp có tính chất như trên thì foreach là lựa chọn tốt nhất.

foreach (int item in IntArray)
{
    Console.Write("\t" + item);
    Sum += item;
}

14. String
String là một kiểu dữ liệu tham chiếu được dùng để lưu trữ chuỗi ký tự. 
Một số phương thức thường dùng trong lớp String:
String.Compare(strA, strB) ; 0 | 1 | -1
String.Concat(strA, strB) ; // Nối chuỗi
String.IsNullOrEmpty(strA) ; 

strA.Substring(3, 1);
Chuẩn hoá tên :
for (int i = 0; i < SubName.Length; i++)
            {
                SubName[i] = SubName[i].Substring(0, 1).ToUpper() +SubName[i].Substring(1).ToLower();
                Result += SubName[i] + " ";
            }

- Lớp StringBuilder trong C# : được .NET xây dựng sẵn giúp chúng ta thao tác trực tiếp với chuỗi gốc và giúp tiết kiệm bộ nhớ hơn so với lớp String.
Cho phép thao tác trực tiếp trên chuỗi ban đầu.
Có khả năng tự mở rộng vùng nhớ khi cần thiết.
Không cho phép lớp khác kế thừa

Khởi tạo một đối tượng rỗng:
StringBuilder <tên biến> = new StringBuilder();
Khởi tạo một đối tượng chứa 1 chuỗi cho trước:
StringBuilder <tên biến> = new StringBuilder(<chuỗi giá trị>);

VD: StringBuilder MutableValue = new StringBuilder("How");
 MutableValue.Append("Kteam");
Trong lớp StringBuilder có các phương thức như: Remove, Insert, Replace được sử dụng hoàn toàn giống như lớp String.
Mới : Append(string value); Clear(); ToString()
Các bạn nhớ đây là đối tượng kiểu StringBuilder nên thao tác với chuỗi như gán, nối chuỗi, . . . phải thông qua các phương thức chứ không thể thực hiện trực tiếp được.

Thông thường đối với các bài toán đòi hỏi thao tác nhiều với chuỗi gốc như cộng chuỗi, chèn chuỗi, xoá bỏ một số ký tự, . . . thì nên sử dụng StringBuilder để tối ưu bộ nhớ.
 Còn lại thì nên sử dụng String để việc thao tác thuận tiện hơn.

15. struct
Struct là một kiểu dữ liệu có cấu trúc, được kết hợp từ các kiểu dữ liệu nguyên thuỷ do người lập trình định nghĩa để thuận tiện trong việc quản lý dữ liệu và lập trình.
Là một kiểu dữ liệu tham trị , Bên trong struct ngoài các biến có kiểu dữ liệu cơ bản còn có các phương thức, các struct khác.
Muốn sử dụng phải khởi tạo cấp phát vùng nhớ cho đối tượng thông qua toán tử new. 

struct SinhVien
{
public int MaSo;
public string HoTen;
public double DiemToan;
public double DiemLy;
public double DiemVan;

}

static void NhapThongTinSinhVien(out SinhVien SV)
        {
            Console.Write(" Ma so: ");
            SV.MaSo = int.Parse(Console.ReadLine());
            Console.Write(" Ho ten: ");
            SV.HoTen = Console.ReadLine();
            Console.Write(" Diem toan: ");
            SV.DiemToan = Double.Parse(Console.ReadLine());
            Console.Write(" Diem ly: ");
            SV.DiemLy = Double.Parse(Console.ReadLine());
            Console.Write(" Diem van: ");
            SV.DiemVan = Double.Parse(Console.ReadLine());
        }

16. Enum trong lập trình C#
Enum là từ khoá dùng để khai báo một kiểu liệt kê (Enumeration). Kiểu liệt kê là một tập hợp các hằng số do người dùng tự định nghĩa.
Là một kiểu dữ liệu tham trị, Enum không được phép kế thừa
enum <tên enum>{
    <danh sách các biểu tượng hằng>
}
<tên enum> là tên kiểu liệt kê do mình tự đặt và tuân thủ theo quy tắc đặt tên (đã trình bày trong bài BIẾN TRONG C#).
<danh sách các biểu tượng hằng> là danh sách các biểu tượng hằng thành phần mỗi biểu tượng hằng cách nhau bằng dấu “,”.

    public const int RED = 0;
    public const int BLUE = 1;
    public const int YELLOW = 2;
Tương đương : Đại diện 0,1,2
enum Color{
    RED,
    BLUE,
    YELLOW
}
Hoặc :
enum Color{
    RED = 2,
    BLUE = 4,
    YELLOW = 6,
}
Nếu ta không quy định giá trị cho các biểu tượng hằng thì giá trị của biểu tượng hằng đầu tiên sẽ mặc định là 0 và tăng dần cho các biểu tượng hằng tiếp theo.
Ta có thể truy xuất đến từng biểu tượng hằng của enum thông qua toán tử “.” Kèm theo tên biểu tượng hằng muốn truy xuất.
VD: Color.RED;
Mặc dù bản chất các biểu tượng hằng là đại diện cho các số nguyên nhưng bạn không thể so sánh trực tiếp chúng với các số nguyên được mà phải ép kiểu
2 == (int)Color.RED;
Color Background = (Color)6; // Background sẽ có giá trị là Color.YELLOW

17. Regular Expression trong C#
Regular Expression hay tiếng Việt được gọi là Biểu thức chính quy, là một cấu trúc rất mạnh để mô tả một chuỗi theo cách thống nhất chung.
Regular Expression bao gồm tập hợp các ký tự, toán tử hay ký hiệu toán học nhằm biểu thị một chuỗi theo cấu trúc chung mà mọi người học theo. 
- Dùng phần mềm RegEx tester để học

                    Tổng quan về lập trình hướng đối tượng

18. Tổng quan về lập trình hướng đối tượng
- là phương pháp lập trình dựa trên kiến trúc lớp (class) và đối tượng (object).

- Đối tượng : đối tượng được hiểu như là 1 thực thể: người, vật hoặc 1 bảng dữ liệu, . . .
Một đối tượng bao gồm 2 thông tin: thuộc tính và phương thức.

- Lớp : Các đối tượng có các đặc tính tương tự nhau được gom lại thành 1 lớp đối tượng.
Bên trong lớp cũng có 2 thành phần chính đó là thuộc tính và phương thức.
Ngoài ra, lớp còn được dùng để định nghĩa ra kiểu dữ liệu mới.

Sự khác nhau giữa đối tượng và lớp :
- Lớp là một khuôn mẫu còn đối tượng là một thể hiện cụ thể dựa trên khuôn mẫu đó.
VD: Khi nói đến xe otô thì lớp chính khuôn mẫu của cái xe với các đặc trưng như có 4 bánh , 
Đối tượng chính là các chiếc xe otô cụ thể như Toyota camry, Honda city, Ford ranger.

Lập trình hướng đối tượng có 4 đặc điểm chính:
- Tính đóng gói
- Tính trừu tượng
- Tính kế thừa
- Tính đa hình

19. Class trong Lập trình hướng đối tượng
- Một class trong C# có các thành phần như:
Thuộc tính: là các thành phần dữ liệu hay còn gọi là các biến.
Phương thức: là các hàm thành phần thể hiện các hành vi của một đối tượng thuộc lớp.
Phương thức khởi tạo.
Phương thức huỷ bỏ.

- Class trong C# thực chất là một kiểu dữ liệu mới do người dùng tự định nghĩa.
Cú pháp:
class <tên lớp>{
     <Phạm vi truy cập> <Các thành phần của lớp>;
}
VD :
class Animal{
        public double Weight;
        public double Height;
        public void Run(){
            Console.WriteLine(" Animal is running. . .");
        }
}

Animal Dog = new Animal();
Dog.Weight = 2; // gán giá trị cho các thuộc tính của đối tượng
Dog.Height = 50;
Animal Cat = new Animal();
Cat.Weight = 1;
Cat.Height = 30;
Dog.Info(); // gọi phương thức của đối tượng
Cat.Info();

Phương thức khởi tạo : 
class Cat{
        public double Weight;
        public double Height;

        public Cat(){
            Weight = 800;
            Height = 10;
        }

        public Cat(int w, int h){
            Weight = w;
            Height = h;

        }
        public void Info(){
            Console.WriteLine(" Height: " + Height + " Weight: " + Weight);
        }
    }

Cat BlackCat = new Cat();
Cat WhiteCat = new Cat(1200, 30);

Phương thức huỷ bỏ :
Có tên trùng với tên lớp nhưng để phân biệt với constructor thì ta thêm dấu “~” vào trước tên lớp.
Không có kiểu trả về.
Vì bộ GC của C# có cơ chế tự động phát hiện đối tượng không còn được sử dụng nữa và thực hiện thu hồi vùng nhớ của nó nên bạn không cần phải viết tường minh việc huỷ vùng nhớ của nó. 
Việc bạn có thể làm viết những thứ bạn muốn làm khi đối tượng bị huỷ vào đây thôi!

20 . Các loại phạm vi truy cập trong Lập trình hướng đối tượng
- public, private, protected, internal, protected internal .
Nếu khai báo lớp mà không chỉ ra phạm vi cụ thể thì phạm vi mặc định là internal.
Nếu khai báo thành phần bên trong lớp mà không chỉ ra phạm vi cụ thể thì phạm vị mặc định là private.

Các thuộc tính thường sẽ có phạm vi là private. 
Các phương thức thường sẽ có phạm vi là public. 

Phương thức truy vấn, phương thức cập nhật :
Trong C#, phương thức truy xuất và phương thức cập nhật đã được nâng cấp lên thành 1 cấu trúc mới ngắn gọn hơn và tiện dụng hơn đó là property.

<kiểu dữ liệu> <tên property> {
            get { return <tên thuộc tính>; }
            set { <tên thuộc tính> = value; }
}

<kiểu dữ liệu> là kiểu dữ liệu của property. Thường sẽ trùng với kiểu dữ liệu của thuộc tính private tương ứng bên trong lớp.
<tên property> là tên do người dùng đặt và tuân theo quy tắc đặt tên đã trình bày trong bài BIẾN TRONG C#.
get, set, value là từ khoá có ý nghĩa:
 Từ khoá get tương đương với phương thức truy vấn.
 Từ khoá set tương đương với phương thức cập nhật.
 Từ khoá value đại diện cho giá trị mà người gán vào property (tương đương với tham số truyền vào của phương thức cập nhật).
<tên thuộc tính> là tên thuộc tính thực sự bên trong lớp.

VD : 
private double diemLy;
public double DiemLy
{
get { return diemLy; }
set { diemLy = value; }
}

SinhVien SV1 = new SinhVien();
SV1.DiemLy = 8; // khi gán giá trị cho property thì các câu lệnh bên trong set sẽ được thực hiện
Console.WriteLine(" Diem ly: " + SV1.DiemLy); // khi lấy giá trị của property thì các câu lệnh bên trong get sẽ được thực hiện.

Có thể viết thêm điều kiện trong get,set :
set{
    if (value <= 10 || value >= 0){
        diemLy = value;
    }
}

21. Từ khóa Static
Đôi lúc người lập trình mong muốn 1 thuộc tính nào đó được dùng chung cho mọi đối tượng (chỉ được cấp phát 1 vùng nhớ duy nhất). 
Từ đó khái niệm thành viên tĩnh ra đời.
- Đặc điểm của thành viên tĩnh:
Được khởi tạo 1 lần duy nhất ngay khi biên dịch chương trình.
Có thể dùng chung cho mọi đối tượng.
Được gọi thông qua tên lớp.
Được huỷ khi kết thúc chương trình.

- Có 4 loại thành viên tĩnh chính:
Biến tĩnh (static variable).
Phương thức tĩnh (static method).
Lớp tĩnh (static class).
Phương thức khởi tạo tĩnh (static constructor).

Biến tĩnh :
public static int Count = 0;

Phương thức tĩnh :
Hàm tĩnh được sử dụng với 2 mục đích chính:
Hàm tĩnh là 1 hàm dùng chung của lớp. Được gọi thông qua tên lớp và không cần khởi tạo bất kỳ đối tượng nào, từ đó tránh việc lãng phí bộ nhớ.
Hỗ trợ trong việc viết các hàm tiện ích để sử dụng lại.
class TienIch{
    public static long LuyThua(int CoSo, int SoMu)
        {
            long KetQua = 1;
            for (int i = 0; i < SoMu; i++){
                KetQua *= CoSo;
            }
            return KetQua;
        }
    }

Lớp tĩnh :
Chỉ chứa các thành phần tĩnh (biến tĩnh, phương thức tĩnh).
Không thể khai báo, khởi tạo 1 đối tượng thuộc lớp tĩnh.
Với 2 đặc điểm trên có thể thấy lớp tĩnh thường được dùng với mục đích khai báo 1 lớp tiện ích chứa các hàm tiện ích hoặc hằng số vì:
Ràng buộc các thành phần bên trong lớp phải là static.
Không cho phép tạo ra các đối tượng dư thừa làm lãng phí bộ nhớ.
Mọi thứ đều được truy cập thông qua tên lớp.
Ví dụ điển hình đó là lớp Math.

Phương thức khởi tạo tĩnh :
Không được phép khai báo phạm vi truy cập. Nếu cố tình làm điều này C# sẽ báo lỗi khi biên dịch.
Constructor tĩnh sẽ được gọi 1 lần duy nhất khi chương trình được nạp vào bộ nhớ để thực thi như là 1 cách để ta thiết lập một số thông số theo ý muốn trước khi có bất kỳ đối tượng nào được tạo ra.
Constructor tĩnh cũng giống phương thức tĩnh nên không thể gọi các thuộc tính không phải static.
static <tên lớp>(){
    // nội dung của constructor
}

22. Kế thừa trong Lập trình hướng đối tượng
Trong lập trình cũng vậy, kế thừa trong lập trình là cách 1 lớp có thể thừa hưởng lại những thuộc tính, phương thức từ 1 lớp khác và sử dụng chúng như là của bản thân mình.
Cho phép xây dựng 1 lớp mới từ lớp đã có.
 Lớp mới gọi là lớp con (subclass) hay lớp dẫn xuất (derived class).
 Lớp đã có gọi là lớp cha (superclass) hay lớp cơ sở (base class).
Cho phép chia sẽ các thông tin chung nhằm tái sử dụng và đồng thời giúp ta dễ dàng nâng cấp, dễ dàng bảo trì.

class Animal{
        protected double Weight;
        protected double Height;
        protected static int Legs;

        public void Info()
        {
            Console.WriteLine(" Weight: " + Weight + " Height: " + Height + " Legs: " + Legs);
        }
    }


class Cat : Animal
    {
        public Cat()
        {
            /*
                Lớp Cat kế thừa lớp Animal
                mà các thuộc tính Weight, Height, Legs có phạm vi là protected nên được phép kế thừa
                Từ đó lớp Cat có thể sử dụng mà không cần phải khai báo

             */
            Weight = 500;
            Height = 20;
            Legs = 2;
        }
    }

Cat BlackCat = new Cat();
/* Lớp Cat kế thừa phương thức Info từ lớp Animal nên đối tượng thuộc lớp Cat có thể gọi phương thức Info() */
BlackCat.Info();

Trong C#, không hỗ trợ đa kế thừa (1 lớp kế thừa từ nhiều lớp) những lại hỗ trợ thực thi nhiều interface (khái niệm về interface sẽ được trình bày trong bài INTERFACE TRONG C#).
Các thành phần của lớp cha có được kế thừa xuống lớp con hay không là do phạm vi truy cập của thành phần đó là gì.
Thành phần có phạm vi là private thì không được kế thừa.
Thành phần có phạm vi là protected, public thì được phép kế thừa.
Phương thức khởi tạo và phương thức huỷ bỏ không được kế thừa.

Phưong thức khởi tạo : Phương thức khởi tạo mặc định của lớp cha luôn luôn được gọi mỗi khi có 1 đối tượng thuộc lớp con khởi tạo. Và được gọi trước phương thức khởi tạo của lớp con.
Từ khoá base : dùng trong constructor và base.Tên_Phương_Thức_ClassCha;
class Animal
    {
        public Animal(double w, double h, int l)
        {
            Weight = w;
            Height = h;
            Legs = l;
        }
    }

class Cat : Animal
    {
        public Cat()
        {         
            Weight = 500;
            Height = 20;
            Legs = 2;
        }

        /*
            Cách gọi constructor của lớp cha thông qua từ khoá base
         */

        public Cat(double w, double h, int l) : base(w, h, l)
        {
          

        }
    }

Từ khoá new : 
Giả sử lớp Animal có phương phức tên Info(). Lớp Cat kế thừa lớp Animal nên cũng sẽ nhận được phương thức này.
Bây giờ trong lớp Cat ta cũng định nghĩa 1 phương thức tên Info(), có kiểu trả về là void và không có tham số truyền vào.
C# sẽ gọi phương thức Info() của lớp Cat định nghĩa. Đồng thời cũng đưa ra 1 cảnh báo khi biên dịch.
Trong C# có hỗ trợ từ khoá new nhằm đánh dấu đây là 1 hàm mới và hàm kế thừa từ lớp cha sẽ bị che đi khiến bên ngoài không thể gọi được.
Từ khoá này chỉ làm tường minh khai báo của hàm Info() chứ về kết quả khi chạy chương trình sẽ không có thay đổi.
VD: 
public new void Info()

{

}

Vậy có cách nào gọi hàm Info() của lớp cha được nữa không?
Câu trả lời là có nhưng chỉ có thể gọi trong nội bộ của lớp Cat mà thôi.
/* Từ khoá new chỉ định đây là 1 hàm Info mới của lớp Cat */
        public new void Info()
        {
           Console.WriteLine(" Info of Cat: ");
           base.Info(); // gọi đến hàm Info() của lớp cha
        }


Vấn đề cấp phát vùng nhớ cho đối tượng :“Một đối tượng thuộc lớp cha có thể tham chiếu đến vùng nhớ của đối tượng thuộc lớp con nhưng ngược lại thì không”.
Animal cat = new Cat();
Cat cat = new Animal ();  // Lỗi

23. Đa hình trong Lập trình hướng đối tượng
Tính đa hình là hiện tượng các đối tượng thuộc các lớp khác nhau có thể hiểu cùng 1 thông điệp theo các cách khác nhau.
Để thể hiện được tính đa hình:
Các lớp phải có quan hệ kế thừa với cùng 1 lớp cha nào đó.
Phương thức đa hình phải được ghi đè (override) ở các lớp con .

Chỉ có thể ghi đè lên phương thức virtual hoặc abstract 
Virtual là từ khoá dùng để khai báo 1 phương thức ảo (phương thức ảo là phương thức có thể ghi đè được).
Override là từ khoá dùng để đánh dấu phương thức ghi đè lên phương thức của lớp cha.

Ta cần khai báo phương thức Speak() của lớp cha là phương thức ảo (virtual).
class Animal
    {
        public virtual void Speak()
        {
            Console.WriteLine(" Animal is speaking. . .");
        }
    }



    class Cat : Animal
    {
        public override void Speak()
        {
            Console.WriteLine(" Cat is speaking. . .");
        }
    }


    class Dog : Animal
    {
        public override void Speak()
        {
            Console.WriteLine(" Dog is speaking. . .");
        }
    }

Lớp trừu tượng và phương thức thuần ảo :
Phương thức thuần ảo là 1  phương thức ảo và không có định nghĩa bên trong.
Lớp trừu tượng là lớp chứa phương thức thuần ảo.
Abstract là từ khoá dùng để khai báo 1 lớp trừu tượng hoặc 1 phương thức thuần ảo.

abstract class Animal
    {
        /*
            Khai báo phương thức thuần ảo nên không cần định nghĩa nội dung cho phương thức
         */

        public abstract void Speak();

    }

Khi kế thừa 1 lớp trừu tượng bạn bắt buộc phải override tất cả các phương thức thuần ảo nhằm đảm bảo tính hợp lệ cho chương trình.

24. Interface trong Lập trình hướng đối tượng
là 1 tập các thành phần chỉ có khai báo mà không có phần định nghĩa (giống phương thức thuần ảo)

Đặc điểm của interface :
Chỉ chứa khai báo không chứa phần định nghĩa (giống phương thức thuần ảo). Mặc dù giống phương thức thuần ảo nhưng bạn không cần phải khai báo từ khoá abstract.
Việc ghi đè 1 thành phần trong interface cũng không cần từ khoá override.
Không thể khai báo phạm vi truy cập cho các thành phần bên trong interface. Các thành phần này sẽ mặc định là public.
Interface không chứa các thuộc tính (các biến) dù là hằng số hay biến tĩnh vẫn không được.
Interface không có constructor cũng không có destructor.
Các lớp có thể thực thi nhiều interface cùng lúc (ở 1 góc độ nào đó có thể nó là phương án thay thế đa kế thừa).
Một interface có thể kế thừa nhiều interface khác nhưng không thể kế thừa bất kỳ lớp nào.

interface ISpeak
    {
        /*
            Khai báo phương thức nhưng không định nghĩa nội dung
         */
        void Speak();
    }

    class Animal : ISpeak // lớp Animal thực thi interface ISpeak
    {
        /*
            Định nghĩa nội dung cho phương thức trong interface
	Phương thức Speak() phải có phạm vi là public vì phương thức Speak() trong interface mặc định là public rồi.
         */
        public void Speak()
        {
            Console.WriteLine("Animal is speaking. . ."); 
        }
    }

Khác nhau  interface và abstract class :
interface : Dùng định nghĩa 1 khuôn mẫu, quy tắc chung
abstract class : Dùng để định nghĩa cốt lõi lớp

Vì việc thực thi interface rất giống với kế thừa nên ta hoàn toàn có thể sử dụng câu lệnh sau:
ISpeak animal = new Animal();


        hóa học lập trình C# nâng cao

25. Tổng quan về Collection trong C#
Các lớp hỗ trợ lưu trữ, quản lý và thao tác với các đối tượng một cách có thứ tự.
Các lớp này nằm trong namespace System.Collections.

Là một mảng có kích thước động:
Không cần khai báo kích thước khi khởi tạo.
Có thể tăng giảm số lượng phần tử trong mảng một cách linh hoạt.
Có thể lưu trữ một tập hợp đối tượng thuộc nhiều kiểu khác nhau.

Một số lớp Collections được sử dụng phổ biến :
- ArrayList : Lớp cho phép lưu trữ và quản lý các phần tử giống mảng.
Tuy nhiên, không giống như trong mảng, ta có thể thêm hoặc xoá phần tử một cách linh hoạt
và có thể tự điều chỉnh kích cỡ một cách tự động.

- HashTable :   Lớp lưu trữ dữ liệu dưới dạng cặp Key – Value.
Khi đó ta sẽ truy xuất các phần tử trong danh sách này thông qua Key
(thay vì thông qua chỉ số phần tử như mảng bình thường).

- SortedList : Là sự kêt hợp của ArrayList và HashTable. Tức là dữ liệu sẽ lưu dưới dạng Key – Value.
 Ta có thể truy xuất các phần tử trong danh sách thông qua Key hoặc thông qua chỉ số phần tử.
 Đặc biệt là các phần tử trong danh sách này luôn được sắp xếp theo giá trị của Key.

-  Stack : 	Lớp cho phép lưu trữ và thao tác dữ liệu theo cấu trúc LIFO (Last In First Out).

- Queue : Lớp cho phép lưu trữ và thao tác dữ liệu theo cấu trúc FIFO (First In First Out).

- BitArray : Lớp cho phép lưu trữ và quản lý một danh sách các bit.
  Giống mảng các phần tử kiểu bool với true biểu thị cho bit 1 và false biểu thị cho bit 0.
  Ngoài ra BitArray còn hỗ trợ một số phương thức cho việc tính toán trên bit.

26. ArrayList trong C#
using System.Collections;

ArrayList trong C#:
Là một Collections giúp lưu trữ và quản lý một danh sách các đối tượng theo kiểu mảng (truy cập các phần tử bên trong thông qua chỉ số index).
Rất giống mảng các object nhưng có thể thêm hoặc xoá các phần tử một cách linh hoạt và có thể tự điều chỉnh kích cỡ một cách tự động.

// khởi tạo 1 ArrayList rỗng
ArrayList MyArray = new ArrayList(); 
// khởi tạo 1 ArrayList và chỉ định Capacity ban đầu là 5
ArrayList MyArray2 = new ArrayList(5); 
/*
 * Khởi tạo 1 ArrayList có kích thước bằng với MyArray2.
 * Sao chép toàn độ phần tử trong MyArray2 vào MyArray3.
*/
ArrayList MyArray3 = new ArrayList(MyArray2);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong ArrayList.
- Capacity :  Trả về 1 số nguyên cho biết số phần tử mà ArrayList có thể chứa (sức chứa).

Phương Thức :
- Add(object Value) : Thêm đối tượng Value vào cuối ArrayList.
- AddRange(ICollection ListObject) : Thêm danh sách phần tử ListObject vào cuối ArrayList.
- BinarySearch(object Value) :Tìm kiếm đối tượng Value trong ArrayList theo thuật toán tìm kiếm nhị phân.
  Nếu tìm thấy sẽ trả về vị trí của phần tử ngược lại trả về giá trị âm. Lưu ý: là ArrayList phải được sắp xếp trước khi sử dụng hàm.
- Clear() : Xoá tất cả các phần tử trong ArrayList.
- Clone() : Tạo 1 bản sao từ ArrayList hiện tại.
- Contains(object Value) : Kiểm tra đối tượng Value có tồn tại trong ArrayList hay không.
- GetRange(int StartIndex, int EndIndex) :  Trả về 1 ArrayList bao gồm các phần tử từ vị trí StartIndex đến EndIndex trong ArrayList ban đầu.
- IndexOf(object Value) : Trả về vị trí đầu tiên xuất hiện đối tượng Value trong ArrayList. Nếu không tìm thấy sẽ trả về -1.
- Insert(int Index, object Value) : Chèn đối tượng Value vào vị trí Index trong ArrayList.
- InsertRange(int Index, ICollection ListObject) : Chèn danh sách phần tử ListObject vào vị trí Index trong ArrayList.
- LastIndexOf(object Value) :  Trả về vị trí xuất hiện cuối cùng của đối tượng Value trong ArrayList. Nếu không tìm thấy sẽ trả về -1.
- Remove(object Value) : Xoá đối tượng Value xuất hiện đầu tiên trong ArrayList.
- Reverse() : Đảo ngược tất cả phần tử trong ArrayList.
- Sort() : Sắp xếp các phần tử trong ArrayList theo thứ tự tăng dần.
- ToArray() : Trả về 1 mảng các object chứa các phần tử được sao chép từ ArrayList.

Sort ( IComparer comparer) 

Tham số truyền vào là 1 lớp có kế thừa từ interface IComparer .
Interface IComparer chứa 1 phương thức duy nhất là:
int Comparer (object x, object y).

Phương thức này sẽ trả về 3 giá trị:
Bé hơn 0 nếu x < y.
Lớn hơn 0 nếu x > y.
Bằng 0 nếu x = y.

- Lớp Người : 
public class Person
    {
        private string name;
        private int age;

        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public int Age
        {
            get { return age; }
            set { age = value; }
        }

        public Person(string Name, int Age)
        {
            this.Name = Name;
            this.Age = Age;
        }
        public override string ToString()
        {
            return "Name: " + name + " | Age: " + age;
        }
    }

- Hàm IComparer trong Sort
 public class SortPersons : IComparer
    {
        public int Compare(object x, object y)
        {
            // Ép kiểu 2 object truyền vào về Person.
            Person p1 = x as Person;
            Person p2 = y as Person;

            /*
             * Vì có thể 2 object truyền vào không phải Person khi đó ta không thể so sánh được.
             * Trường hợp này tốt nhất ta nên ném ra lỗi để lập trình viên sửa chữa.
             * Chi tiết về exception sẽ được trình bày ở những bài học sau.
             */
            if (p1 == null || p2 == null)
            {
                throw new InvalidOperationException();
            }
            else
            {
                if (p1.Age > p2.Age)
                {
                    return 1;
                }
                else if (p1.Age == p2.Age)
                {
                    return 0;
                }
                else
                {
                    return -1;
                }
            }
        }
    }

- Cách Dùng :
// Tạo 1 danh sách kiểu ArrayList rỗng
ArrayList arrPersons = new ArrayList();

// Thêm 3 Person vào danh sách
arrPersons.Add(new Person("Nguyen Van A", 18));
arrPersons.Add(new Person("Nguyen Van B", 25));
arrPersons.Add(new Person("Nguyen Van C", 20));

// In thử danh sách Person ban đầu ra.
Console.WriteLine("Danh sach Person ban dau: ");
foreach (Person item in arrPersons)
{
    Console.WriteLine(item.ToString());
}

/* 
 * Thực hiện sắp xếp danh sách Person theo tiêu chí đã được định nghĩa 
 * trong phương thức Compare của lớp SortPerson (tuổi tăng dần).
*/
arrPersons.Sort(new SortPersons());

// In danh sách Person đã được sắp xếp ra màn hình.
Console.WriteLine();
Console.WriteLine("Danh sach Person da duoc sap xep theo tuoi tang dan: ");
foreach (Person item in arrPersons)
{
    Console.WriteLine(item.ToString());
}

27. HashTable trong C# 
- Là một Collections lưu trữ dữ liệu dưới dạng cặp Key - Value :
Key đại diện cho 1 khoá giống như chỉ số phần tử của mảng và Value chính là giá trị tương ứng của khoá đó.
Ta sẽ dử dụng Key để truy cập đến Value tương ứng.
Vì Key và Value đều là kiểu object nên ta có thể lưu trữ được mọi kiểu dữ liệu từ những kiểu cơ sở đến kiểu phức tạp (class).
Vì Hashtable là một lớp nên trước khi sử dụng ta cần khởi tạo vùng nhớ bằng toán tử new

using System.Collections;

// khởi tạo 1 Hashtable rỗng
Hashtable MyHash = new Hashtable(); 
// khởi tạo 1 Hashtable và chỉ định Capacity ban đầu là 5
Hashtable MyHash2 = new Hashtable(5); 
/*
 * Khởi tạo 1 Hashtable có kích thước bằng với MyHash2.
 * Sao chép toàn độ phần tử trong MyHash2 vào MyHash3.
 */
Hashtable MyHash3 = new Hashtable(MyHash2);

Thuộc tính :
- Count :  Trả về 1 số nguyên là số phần tử hiện có trong Hashtable.
- Keys : Trả về 1 danh sách chứa các Key trong Hashtable.
- Values : Trả về 1 danh sách chứa các Value trong Hashtable.

Phương thức :
- Add(object Key, object Value) :  Thêm 1 cặp Key - Value vào Hashtable.
- Clear() : Xoá tất cả các phần tử trong Hashtable.
- Clone() : Tạo 1 bản sao từ Hashtable hiện tại.
- ContainsKey(object Key) : Kiểm tra đối tượng Key có tồn tại trong Hashtable hay không.
- ContainsValue(object Value) : Kiểm tra đối tượng Value có tồn tại trong Hashtable hay không.
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong Hashtable sang mảng một chiều array từ vị trí Index của array.
Lưu ý: array phải là mảng các object hoặc mảng các DictionaryEntry.
- Remove(object Key) :  Xoá đối tượng có Key xuất hiện đầu tiên trong Hashtable.

Một số lưu ý về Hashtable : 
Mỗi một phần tử trong Hashtable (bao gồm 1 cặp Key - Value) được C# định nghĩa là 1 đối tượng có kiểu DictionaryEntry. 
Trong DictionaryEntry có 2 thuộc tính chính:
Key: trả về giá trị Key của phần tử hiện tại.
Value: trả về giá trị Value của phần tử hiện tại.

// Tạo một Hashtable đơn giản với 3 phần tử
            Hashtable hash = new Hashtable();
            hash.Add("K", "Kteam");
            hash.Add("H", "HowKteam");
            hash.Add("FE", "Free Education");

            /* 
             * Duyệt qua các phần tử trong Hashtable.
 * Vì mỗi phần tử là 1 DictionaryEntry nên ta chỉ định kiểu dữ liệu cho item là DictionaryEntry luôn.
             * Thử in ra màn hình cặp Key - Value của mỗi phần tử được duyệt.
             */
            foreach (DictionaryEntry item in hash)
            {
                Console.WriteLine(item.Key + "\t" + item.Value);   
            }

Truy xuất các phần tử trong Hashtable
Console.WriteLine(MyHash["One"]);

Ta nên cẩn thận khi truy xuất các phần tử trong Hashtable thông qua Key:
Nếu ta thực hiện lấy giá trị 1 phần tử trong Hashtable với Key không tồn tại thì sẽ ra giá trị null và không báo lỗi.
Nếu ta thực hiện gán giá trị cho 1 phần tử trong Hashtable tại vị trí Key không tồn tại thì Hashtable sẽ tự thêm 1 phần tử mới với Key và Value như trên. 
Điều này có thể làm phát sinh thêm các phần tử không mong muốn trong danh sách.

28. SortedList trong C# 
SortedList cũng là một Collections lưu trữ dữ liệu dưới dạng cặp Key - Value. 
Key đại diện cho 1 khoá giống như chỉ số phần tử của mảng và Value chính là giá trị tương ứng của khoá đó.
Là 1 Hashtable nhưng các giá trị được sắp xếp theo Key. 
Việc sắp xếp này được thực hiện một cách tự động mỗi khi thêm 1 phần tử mới vào SortedList.
Có thể truy xuất đến các phần tử trong SortedListthông qua Key(như Hashtable) hoặc thông qua chỉ số phần tử (như ArrayList).
SortedList chính là sự kết hợp giữa ArrayList với Hashtable .

using System.Collections;

// khởi tạo 1 SortedList rỗng
SortedList MySL = new SortedList(); 
// khởi tạo 1 SortedList và chỉ định Capacity ban đầu là 5
SortedList MySL2 = new SortedList(5); 
/*
 * Khởi tạo 1 SortedList có kích thước bằng với MySL2.
 * Sao chép toàn độ phần tử trong MySL2 vào MySL3.
 */
SortedList MySL3 = new SortedList(MySL2);
/*
 * Mình định nghĩa 1 lớp PersonComparer có thực thi 1 interface IComparer
 * Sau đó override lại phương thức Compare.
 * Sử dụng lớp trên để truyển vào constructor của SortedList.
 */
SortedList MySL4 = new SortedList(new PersonComparer());
/*
 * Tạo 1 SortedList mới và sao chép các phần tử từ MySL3 đồng thời sắp xếp các phần tử lại
 * theo cách sắp xếp được định nghĩa trong lớp PersonComparer.
 */
SortedList MySL5 = new SortedList(MySL3, new PersonComparer());

Vì SortedList là sự kết hợp giữa ArrayList và Hashtable nên nó sẽ mang các thuộc tính, phương thức giống 2 Collections trên và một vài phương thức mới.
Thuộc Tính : Count, Capacity, Keys, Values

Phương Thức :
- Add(object Key, object Value)
- Clear(),  Clone(), ContainsKey(object Key), ContainsValue(object Value)
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong SortedList sang mảng một chiều array từ vị trí Index của array.
Lưu ý: array phải là mảng các object hoặc mảng các DictionaryEntry.
- GetByIndex(int Index) : Trả về giá trị Value tại vị trí Index trong SortedList.
- GetKey(int Index) : Trả về giá trị Key tại vị trí Index trong SortedList.
- GetKeyList() :  Trả về 1 List các Key trong SortedList. 
- GetValueList() : Trả về 1 List các Value trong SortedList.
- IndexOfKey(object Key) : Trả về 1 số nguyên là chỉ số phần tử của 1 Key trong SortedList.
- Remove(object Key) : Xoá đối tượng có Key xuất hiện đầu tiên trong SortedList.
- RemoveAt(int Index) : Xoá đối tượng tại vị trí Index trong SortedList.
- SetByIndex(int Index, object Value) : Gán giá trị Value mới tại vị trí Index trong SortedList.

Một số lưu ý :
Nếu bạn muốn các giá trị Key là các đối tượng thuộc 1 lớp nào đó thì bạn phải định nghĩa cách so sánh đối tượng đó. 
Nếu không chương trình sẽ báo lỗi vì nó không biết phải sắp xếp các Key này như thế nào. 
// Lỗi do chưa định nghĩa cách so sánh cho Person
SortedList MySL6 = new SortedList();
MySL6.Add(new Person("HowKteam", 20), 10);
MySL6.Add(new Person("Kteam", 2), 15);
// Để khắc phục điều này ta có thể định nghĩa 1 lớp thực thi interface IComparer và định nghĩa cách sắp xếp trong hàm Comparer(Bên trên)
// tạo 1 SortedList và truyền vào cách sắp xếp các Key trong SortedList này.
            SortedList MySL6 = new SortedList(new PersonComparer());
// Nên override lại cả phương thức toString để việc in ra Key và Value không bị lỗi:
Ta thử override phương thức ToString trong lớp Person:
public override string ToString()
{
     return Name + " : " + Age;
}

29. Stack trong C#
Stack là một Collections đại diện cho một danh sách hoạt động theo nguyên lý LIFO

using System.Collections;
// khởi tạo 1 Stack rỗng
Stack MyStack = new Stack();
// khởi tạo 1 Stack và chỉ định sức chứa ban đầu là 5
Stack MyStack = new Stack(5); 
// khởi tạo 1 mảng bất kỳ
ArrayList MyArray = new ArrayList();
MyArray.Add(5);
MyArray.Add(9);
MyArray.Add(10);
// Khởi tạo 1 Stack và sao chép giá trị của các phần tử từ MyArray vào Stack.
Stack MyStack3 = new Stack(MyArray);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong Stack.
Phương Thức : 
- Clear(),Clone(),  Contains (object Value), Contains (object Value), CopyTo(Array array, int Index)
- Peek() : Trả về giá trị của đối tượng tại vị trí trên cùng trong Stack (phần tử thêm vào cuối cùng) nhưng không xoá phần tử khỏi Stack.
- Pop() :  Trả về giá trị của đối tượng tại vị trí trên cùng trong Stack(phần tử thêm vào cuối cùng) đồng thời xoá phần tử khỏi Stack.
- Push(object Value) : Thêm một phần tử có giá trị Value vào vị trí trên cùng trong Stack.
- ToArray() : Tạo ra 1 mảng các object chứa tất cả các phần tử trong Stack và trả về mảng đó.

30. Queue trong C#
- là một cấu trúc dữ liệu hoạt động theo nguyên lý FIFO (First In First Out). 

using System.Collections;

// khởi tạo 1 Queue rỗng
Queue MyQueue = new Queue(); 
// khởi tạo 1 Queue và chỉ định sức chứa ban đầu là 5
Queue MyQueue2 = new Queue(5); 
// khởi tạo 1 mảng bất kỳ
ArrayList MyArray = new ArrayList();
MyArray.Add(5);
MyArray.Add(9);
MyArray.Add(10);
// Khởi tạo 1 Queue và sao chép giá trị của các phần tử từ MyArray vào Queue.
Queue MyQueue3 = new Queue(MyArray);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong Queue .

Phương Thức :
- Clear(), Clone(), Contains (object Value), 
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong Queue sang mảng một chiều array từ vị trí Index của array.
- Enqueue () : Trả về giá trị của đối tượng tại vị trí đầu trong Queue (phần tử thêm vào đầu tiên) nhưng không xoá phần tử khỏi Queue.
- Dequeue() : Trả về giá trị của đối tượng tại vị trí đầu trong Queue(phần tử thêm vào đầu tiên)đồng thời xoá phần tử khỏi Queue.
- Push(object Value) :  Thêm một phần tử có giá trị Value vào đầu Queue.
- ToArray() : Tạo ra 1 mảng các object  chứa tất cả các phần tử trong Queue và trả về mảng đó.

31. BitArray trong C#
- BitArray là một Collections giúp quản lý, lưu trữ một danh sách các bit (0 hoặc 1),
Ta có thể truy cập đến các phần tử trong BitArray thông qua chỉ số như ArrayList.
Lưu ý: là ta không thể khởi tạo 1 BitArray rỗng!

/*
 * Khởi tạo 1 BitArray có 10 phần tử. 
 * Mỗi phần tử có giá trị mặc định 0 (false).
 */
BitArray MyBA = new BitArray(10); 
/*
 * Khởi tạo 1 BitArray có 10 phần tử. 
 * Mỗi phần tử có giá trị mặc định 1 (true).
 */
BitArray MyBA2 = new BitArray(10, true);
/*
 * Khởi tạo 1 BitArray từ một mảng bool có sẵn.
 */
bool[] MyBools = new bool[5] { true, false, true, true, false };
BitArray MyBA3 = new BitArray(MyBools); // 1 0 1 1 0

/*
 * Khởi tạo 1 BitArray từ một mảng byte có sẵn.
 * biễu diễn mỗi số bằng 8 bit, vậy mảng bitArray gồm 8*5 phần tử
 */
byte[] MyBytes = new byte[5] { 1, 2, 3, 4, 5 };
BitArray MyBA4 = new BitArray(MyBytes);
/*
* Khởi tạo 1 BitArray từ một mảng int có sẵn.
* biễu diễn mỗi số bằng 32 bit, vậy mảng bitArray gồm 32*5 phần tử
*/
int[] MyInts = new int[5] { 1, 2, 3, 4, 5 };
BitArray MyBA5 = new BitArray(MyInts);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong BitArray. 
- Length : Trả về 1 số nguyên là số phần tử hiện có trong BitArray. 
Đồng thời có thể thay đổi kích thước của BitArray bằng cách gán giá trị mới cho thuộc tính này.

Phương Thức : 
- And(BitArrayValue) :  Thực hiện phép toán AND bit giữa dãy bit hiện tại với dãy bit Value 
và trả về 1 BitArray là kết quả của phép toán trên.

- Clone() : Tạo 1 bản sao từ BitArray hiện tại.
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong BitArray sang mảng một chiều array từ vị trí Index của array.
- Get(int Index) : Trả về giá trị của bit tại vị trí Index trong BitArray.
- Not() : Trả về 1 BitArray là kết quả của phép toán NOT trên dãy bit hiện tại.
- Or(BitArray Value) : Trả về 1 BitArray là kết quả của phép toán OR giữa dãy bit hiện tại với dãy bit Value.
- Set(int Index, bool Value) : Gán giá trị cho bit tại vị trí Index với giá trị mới là Value.
- SetAll(bool Value) :  Gán giá trị cho toàn bộ các bit trong BitArray với giá trị mới là Value.
- Xor(BitArray Value) : Trả về 1 BitArray là kết quả của phép toán XOR giữa dãy bit hiện tại với dãy bit Value.

Lưu ý:
Các phép toán AND, OR, NOT, XOR phải được thực hiện trên 2 BitArray có cùng độ dài nếu không sẽ báo lỗi.
Các phép toán AND, OR, NOT, XOR sẽ làm thay đổi cả BitArray gọi nó. 
Ví dụ:
BitArray A = new BitArray(5);
BitArray B = new BitArray(5, true);
A.And(B);
Thì kết quả của phép AND sẽ được cập nhật giá trị vào BitArray A.

32. Generic trong C#
- Giống khái niệm Template (hay còn gọi là mẫu) trong c++ Generic trong C# cho phép bạn định nghĩa một hàm, một lớp mà không cần chỉ ra đối số kiểu dữ liệu là gì. 
Tuỳ vào kiểu dữ liệu mà người dùng truyền vào thì nó sẽ hoạt động theo kiểu dữ liệu đó.

- Đổi 2 số nguyên : 
public static void Swap(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

- Đổi 2 số bất kì : 
public static void Swap<T>(ref T a, ref T b)
{
    T temp = a;
    a = b;
    b = temp;
}

- Cách Dùng :
int a = 5, b = 7;
double c = 1.2, d = 5.6;

Swap<int>(ref a, ref b);
Swap<double>(ref c, ref d);

- Dùng cho lớp :
public class MyGeneric<T>
{
    private T[] items;

    public T[] Items
    {
        get { return items; }
    }

    public MyGeneric(int Size)
    {
        items = new T[Size];
    }

    public T GetByIndex(int Index)
    {
        // Nếu index vượt ra khỏi chỉ số phần tử của mảng thì ném ra ngoại lệ
        if (Index < 0 || Index >= items.Length)
        {
            throw new IndexOutOfRangeException();
        }
        else
        {
            return items[Index];
        }
    }

    public void SetItemValue(int Index, T Value)
    {
        if (Index < 0 || Index >= items.Length)
        {
            throw new IndexOutOfRangeException();
        }
        else
        {
            items[Index] = Value;
        }
    }
}

// Khởi tạo 1 mảng số nguyên kiểu int có 5 phần tử
MyGeneric<int> MyG = new MyGeneric<int>(5);
MyG.SetItemValue(0, 10);

- Tác dụng của Generic : 
+ Các Collections đều lưu giá trị bên trong là object nên ta khó kiểm soát rằng việc thêm phần tử có phải cùng kiểu dữ liệu ta mong muốn hay không.
+ Muốn quản lý 1 danh sách có cùng kiểu ta dùng Generic Collections.
+ Các Generic Collections đều được xây dựng bắt nguồn từ 1 Collections nào đó có sẵn.Nên mỗi Collections đã học sẽ có một Generic tương ứng.

- Một số Generic Collections được sử dụng phổ biến :
+ List<T> : Thay thế cho ArrayList đã học.
+ Dictionary<Tkey, TValue> : Thay thế cho Hashtable đã học.
+ SortedDictionary<Tkey, TValue> : Thay thế cho SortedList đã học.
+ Stack<T> : Thay thế cho Stack đã học.
+ Queue<T> : Thay thế cho Queue đã học.

33. List trong C#
- List là 1 Generic Collections đưa ra như một sự thay thế ArrayList vì thế về khái niệm cũng như sử dụng nó hoàn toàn giống với ArrayList.

using System.Collections.Generic;

// khởi tạo 1 List các số nguyên rỗng
List<int> MyList = new List<int>(); 
// khởi tạo 1 List các số nguyên và chỉ định Capacity ban đầu là 5
List<int> MyList2 = new List<int>(5);
/*
 * Khởi tạo 1 List số nguyên có kích thước bằng với MyList2.
 * Sao chép toàn độ phần tử trong MyList2 vào MyList3.
 */
List<int> MyList3 = new List<int>(MyList2);

Thuộc Tính, Phương Thức giống ArrayList .

34. Dictionary trong C#
-  là sự thay thế cho Collections Hashtable .

using System.Collections.Generic;

// khởi tạo 1 Dictionary rỗng với Key và Value đều có kiểu dữ liệu là chuỗi.
Dictionary<string, string> MyHash = new Dictionary<string, string>(); 
/* 
 * khởi tạo 1 Dictionary với Key và Value có kiểu chuỗi 
 * đồng thời chỉ định Capacity ban đầu là 5
 */
Dictionary<string, string> MyDic2 = new Dictionary<string, string>(5);
 /*
 * Khởi tạo 1 Dictionary có kích thước bằng với MyDic2.
 * Sao chép toàn độ phần tử trong MyDic2 vào MyDic3.
 */
Dictionary<string, string> MyDic3 = new Dictionary<string, string>(MyDic2);

Thuộc Tính, Phương Thức giống Hashtable .

35 . Tuple trong C#
Tuple là một kiểu dữ liệu có cấu trúc, giúp lưu trữ các dữ liệu phức tạp mà không cần phải tạo ra một struct hay class mới 
Tuple là một cấu trúc dữ liệu bất biến (immutable) trong C#, có nghĩa là sau khi bạn gán giá trị cho các phần tử của tuple, bạn không thể thay đổi chúng. 
Tuy nhiên, bạn có thể tạo một tuple mới với giá trị mới hoặc sử dụng một giá trị khác để thay thế tuple hiện tại.
C# cung cấp cho chúng ta 8 lớp generic :
public class Tuple <T1>
public class Tuple <T1, T2>
public class Tuple <T1, T2, T3>
public class Tuple <T1, T2, T3, T4>
public class Tuple <T1, T2, T3, T4, T5>
public class Tuple <T1, T2, T3, T4, T5, T6>
public class Tuple <T1, T2, T3, T4, T5, T6, T7>
public class Tuple <T1, T2, T3, T4, T5, T6, T7, TRest>

- Dùng Tuple tiện hơn struct hoặc class , Tuple đã override sẵn:
 Phương thức Equals (phương thức dùng để so sánh 2 đối tượng).
 Phương thức ToString (Phương thức chuyển giá trị đối tượng sang chuỗi).
 Phương thức GetHashCode (Phương thức trả về mã băm của một đối tượng, dùng để hỗ trợ so sánh 2 đối tượng).

Khởi tạo một đối tượng Tuplechúng ta có 2 cách:
- Thông qua phương thức Create trong lớp Tuple:
// Khởi tạo Tuple thông qua phương thức Create
var MyTuple = Tuple.Create<int, string>(1, "HowKteam");
- Thông qua Constructor của các lớp Generic:
// Khởi tạo Tuple thông qua constructor của các lớp generic
var MyTuple2 = new Tuple<int, string>(2, "Kteam");

Lấy giá trị :
// Lấy giá trị bên trong Tuple
Console.WriteLine(" ID: {0}, Name: {1}",MyTuple.Item1, MyTuple.Item2);

Lưu ý: Các thuộc tính Item1, Item2, Item3,… là các thuộc tính chỉ đọc nghĩa là bạn chỉ có thể gọi ra để lấy giá trị chứ không thể gán giá trị cho chúng được.

36.ICollection trong C#
- ICollection là một interface trong bộ các interface được định nghĩa sẵn của .NET Framework.
ICollection đây là 1 interface thể hiện tính chất của 1 collection.
- Interface ICollection yêu cầu chúng ta thực thi những Property, phương thức sau:
Count: trả về số lượng phần tử của tập hợp.
IsSynchronized và SyncRoot: 2 property để làm cho thao tác đa luồng với tập hợp an toàn hơn.
CopyTo(Array array, int index): phương thức thực hiện copy tập hợp ra 1 mảng, bắt đầu từ vị trí index trong tập hợp.
GetEnumerator(): Trả về 1 đối tượng kiểu IEnumerator.

public class MyArrayList : ICollection
    {
        private object[] lstObj; // mảng giá trị
        private int count; // số lượng phần tử
        private const int MAXCOUNT = 100; // số lượng phần tử tối đa

        public MyArrayList()
        {
            count = -1;
            lstObj = new object[MAXCOUNT];
        }

        public MyArrayList(int count)
        {
            this.count = count;
            lstObj = new object[count];
        }

        public MyArrayList(Array array)
        {
            array.CopyTo(lstObj, 0);
            count = array.Length;
        }

        public void CopyTo(Array array, int index)
        {
            // thực hiện copy các phần tử trong lstObj từ vị trí index đến cuối sang mảng array.
            lstObj.CopyTo(array, index);
        }

        public int Count
        {
            get { return count; }
        }

        public bool IsSynchronized
        {
            get { throw new NotImplementedException(); }
        }

        public object SyncRoot
        {
            get { throw new NotImplementedException(); }
        }

        public IEnumerator GetEnumerator()
        {
            throw new NotImplementedException();
        }
    }

37. Delegate trong C#
Delegate trong C# tương tự như con trỏ hàm trong C hoặc C++.
Delegate là một biến kiểu tham chiếu(references) chứa tham chiếu tới một phương thức.
Bạn cứ hiểu Delegate là một biến bình thường, biến này chứa hàm mà bạn cần gọi. Sau này lôi ra sài như hàm bình thường.

using System.Delegate;

Khai báo Delegate trong C# sẽ tương tự như khai báo một biến. Nhưng cần thêm từ khóa Delegate để xác định đây là một Delegate. 
Đồng thời vì Delegate là để tham chiếu đến một hàm, nên cũng cần khai báo kèm kiểu dữ liệu trả về của và tham số đầu vào của Delegate tương ứng với hàm tham chiếu.
Khai báo :
delegate <kiểu trả về> <tên delegate> (<danh sách tham số nếu có>);

delegate int MyDelegate(string s);
Tạo một Delegate có tên là MyDelegate. MyDelegate có kiểu trả về là int, một tham số đầu vào là string.

class Program
    	{
        delegate int MyDelegate(string s);
        static void Main(string[] args)
        {
            Console.OutputEncoding = Encoding.Unicode;

            MyDelegate convertToInt = new MyDelegate(ConvertStringToInt);

            string numberSTR = "35";

            int valueConverted = convertToInt(numberSTR);

            Console.WriteLine("Giá trị đã convert thành int: " + valueConverted); 

            Console.ReadLine();
        }

        static int ConvertStringToInt(string stringValue)
        {
            int valueInt = 0;

            Int32.TryParse(stringValue, out valueInt);
            Console.WriteLine("Đã ép kiểu dữ liệu thành công");

            return valueInt;        
        }
    	}

if (showLog != null) showLog("Mgs") hoặc gắn gọn hơn showLog?.Invoke("Mgs");

Vì sao cần Delegate? Khi bạn cần dùng một hàm như một biến ví dụ như tham số truyền vào của một hàm, hàm call-back, event…
Khi bạn cần thực hiện một chuỗi hàm với cùng kiểu trả về và cùng tham số đầu vào mà không muốn gọi nhiều hàm tuần tự (chỉ gọi 1 hàm 1 lần duy nhất). 
Bạn sẽ cần dùng đến Multicast Delegate. Bạn có thể làm một chuỗi Delegate cùng kiểu Delegate bằng cách dùng toán tử + ,loại bỏ Delegate trong multicast bằng toán tử -
class Program
    	{
        delegate int MyDelegate(string s);
        static void Main(string[] args)
        {
            Console.OutputEncoding = Encoding.Unicode;

            MyDelegate convertToInt = new MyDelegate(ConvertStringToInt);
            MyDelegate showString = new MyDelegate(ShowString);
            MyDelegate multicast = convertToInt + showString;
            string numberSTR = "35";

            multicast(numberSTR); // Delegate multicast để thực hiện 1 lần 2 Delegate tuần tự là convertToInt và showString.

            Console.ReadLine();
        }

        static int ConvertStringToInt(string stringValue)
        {
            int valueInt = 0;
            Int32.TryParse(stringValue, out valueInt);
            Console.WriteLine("Đã ép kiểu dữ liệu thành công");
            return valueInt;        
        }

        static int ShowString(string stringValue)
        {
            Console.WriteLine(stringValue);
            return 0;
        }
    	}

Khi cần loại bỏ Delegate trong multicast bạn chỉ việc trừ Delegate ra : multicast = multicast - showString;

Dùng Delegate cho call-back function : 

  delegate int MyDelegate(string s);
        static void Main(string[] args)
        {
            Console.OutputEncoding = Encoding.Unicode;           

            MyDelegate showString = new MyDelegate(ShowString);            

            NhapVaShowTen(showString);

            Console.ReadLine();
        }

        static void NhapVaShowTen(MyDelegate showTen) // 
        {
            Console.WriteLine("Mời nhập tên của bạn:");
            string ten = Console.ReadLine();
            showTen(ten);
        }

        static int ShowString(string stringValue)
        {
            Console.WriteLine(stringValue);
            return 0;
      }



38 . Event với Delegate trong C#
Event là Delegate với mục đích để cho lớp khác hoặc đối tượng cha của đối tượng hiện tại ủy thác(định nghĩa) hàm vào trong đó.
Khai báo Event trong C# sẽ tương tự như khai báo một biến. Nhưng biến này sẽ nhận kiểu dữ liệu là Delegate đã được tạo trước đó. Lưu ý: event phải public.

event <Kiểu delegate> <tên event>;
event UpdateNameHandler NameChanged;

namespace Event_Voi_Delegate
{
    		public delegate void UpdateNameHandler(string name);
    		class Program
    		{
        		static void Main(string[] args)
        		{
        		}
    		}

    		public class HocSinh
    		{
        		public event UpdateNameHandler NameChanged;

        		private string _Name;
        		public string Name
        		{
            		get => _Name;
            		set
            		{
                			_Name = value;
            		}
        		}
    		}
}

Event phải được ủy thác từ đối tượng cha của đối tượng chứa event . 
Bằng cách += hàm Delegate tương ứng vào event của đối tượng(Tương tự có thể loại bỏ bằng cách -=).

HocSinh hs = new HocSinh();
hs.NameChanged += Hs_NameChanged;

Hàm Hs_NameChanged lúc này được tự tạo ra bằng cách gõ cú pháp sau :  hs.NameChanged += "  và nhấn phím tab một lần .
Hàm Hs_NameChanged lúc này được tự tạo ra bên dưới hàm Main với kiểu trả về và tham số đầu vào tương ứng với Delegate UpdateNameHandler.

Hoặc bạn cũng có thể dùng anonymous method trong tình huống này:
hs.NameChanged += (name) =>
      {
            Console.WriteLine("Tên mới: " + name);
      };


code ví dụ mẫu :
namespace Event_Voi_Delegate
{
    public delegate void UpdateNameHandler(string name);
    class Program
    {
        static void Main(string[] args)
        {
            Console.OutputEncoding = Encoding.Unicode;

            HocSinh hs = new HocSinh();

            hs.NameChanged += Hs_NameChanged;

            hs.Name = "Kteam";
            Console.WriteLine("Tên từ class: " + hs.Name);
            hs.Name = "HowKteam.com";
            Console.WriteLine("Tên từ class: " + hs.Name);

            Console.ReadLine();
        }

        private static void Hs_NameChanged(string name)
        {
            Console.WriteLine("Tên mới: " + name);
        }
    }

    public class HocSinh
    {
        public event UpdateNameHandler NameChanged;

        private string _Name;
        public string Name
        {
            get => _Name;
            set
            {
                _Name = value;
                if(NameChanged != null) // Kiểm tra để không bị null exception.
                {
                    NameChanged(Name);
                }
            }
        }
    }
}

39 . Event chuẩn .Net trong C#
Event chuẩn .Net là event với Delegate nhưng thỏa mãn các điều kiện:
Delegate có kiểu trả về là void
Delegate có hai tham số, tham số thứ nhất có kiểu dữ liệu là object, tham số thứ hai có kiểu EventArgs. 
object chính là đối tượng phát sinh sự kiện, EventArgs chính là class giữ thông tin mà đối tượng gửi kèm trong quá trình phát sinh sự kiện.
Lúc này thay vì chúng ta dùng Delegate do chúng ta tự tạo thì .Net có sẵn Delegate tên là EventHandler theo chuẩn ở trên.
Vậy các event có sẵn trong .Net như Console.CancelKeyPress hay nhiều event khác nữa
Các event này thường được đánh ký hiệu là tia sét

public delegate void EventHandler(object sender?, EventArgs e);
public delegate void EventHandler<TEventArgs>(object sender?, TEventArgs e);

40 . Namespace là gì trong C#
Một namespace bạn có thể định nghĩa ở nhiều file code (.cs) khác nhau. 
Khi muốn sử dụng các thành phần của namespace nào đó, thì dùng từ khóa using ở đầu file code để chỉ thị nạp namespace này vào

using mynamespace;

Namespace Systems; là namepace cơ sở hệ thống của .NET, nên hầu như mọi chương trình đều có đoạn code using Systems; ở đầu.
Các namespace cũng có thể khai báo lồng nhau, nhiều cấp sau đó dùng ký hiệu . để truy cập đến namepace mong muốn, ví dụ namepace B nằm trong namspace A
namespace A {
    // Định nghĩa các lớp, cấu trúc ...
    namespace B {
        // Định nghĩa các lớp, cấu trúc ...
    }
}
using A.B;

namespace A
{
    public struct StructInA {};
}
namespace A.B 
{
    public struct StructInB {};
}
namespace A.B.C
{
    public struct StructInC {};
}
Cách khai báo này hoàn toàn giống:

namespace A
{
    public struct StructInA { };

    namespace B
    {
        public struct StructInB { };

        namespace C
        {
            public struct StructInC { };
        }
    }
}

Truy cập namespace và từ khóa using :
Ví dụ, lớp StringBuilder được định nghĩa trong namespace System.Text, vậy để dùng nó trong code bạn phải viết với tên đầy đủ System.Text.StringBuilder:
System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();

Hoặc sử dụng StructInC ở trên bạn phải viết:
A.B.C.StructInC mystruct;
Để tránh phải viết tên đầy đủ như vậy bạn sử dụng đến từ khóa using với namespace cần dùng ở đầu. Ví dụ:
using System.Text;
//... các thành phần khác

    static void Main (string[] args) {

        StringBuilder stringBuilder = new StringBuilder();
         // Không cần viết: System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();
    }
Sử dụng using chỉ thị truy cập trực tiếp các phương thức tĩnh, mà không cần viết tên lớp cú pháp nạp phương thức tĩnh của lớp có dạng using static namespace ... class.

Ví dụ phương thức tĩnh WriteLine trong WriteLine:
using static System.Console;  // cho biết sử dụng trực tiếp các phương thức tĩnh
//..
    WriteLine ("Xin chào C# NET CORE!");
//..

41 . Partial Type và Nested Type
Partial là kỹ thuật phân chia code lưu ở nhiều file mã nguồn khác nhau, khi biên dịch thì nó tổng hợp lại thành một. 
Kỹ thuật này dùng với từ khóa partial khi định nghĩa lớp, giao diện, struct.
public partial class A { }

Product1.cs

using System;
namespace CS007B_PARTIAL
{
    public partial class Product {
      public string Name { set; get;}

      public bool Order(int number = 0)
      {
        return true;
      }
    }
}

Product2.cs

using System;
namespace CS007B_PARTIAL
{
    public partial class Product {

        public int numberBrought()
        {
            return 100;
        }

    }
}
Lưu ý khi dùng partial : Trong định nghĩa ở tất cả các phần phải có từ khóa partial

Lớp lồng nhau (kiểu Nested) trong C#
Trong C# nó cho phép bạn khai báo một lớp (class), giao diện (interface), cấu trúc (struct) trong thân một lớp khác - chúng được gọi là kiểu lồng nhau (Nested Type)
public class Container
{
    public class Nested
    {
        public Nested() { }
    }
}
Lớp Nested được khai báo, định nghĩa trong lớp Container, nếu phạm vị lớp public, thì bên ngoài sử dụng lớp con này bằng cách chỉ rõ Container.Nested
Container.Nested nested = new Container.Nested();

42. null và null nullable
null là một giá trị cố định nó biểu thị không có đối tượng nào cả, có nghĩa là biến có giá trị null không có tham chiếu (trỏ) đến đối tượng nào (không có gì).
null chỉ có thể gán được cho các biến kiểu tham chiếu (biến có kiểu dữ liệu là các lớp), không thể gán null cho những biến có kiểu dữ liệu dạng tham trị như int, float, bool ...

MyClass refvar1, refvar2;
refvar1 = new MyClass();    // refvar1 tham chiếu (gán) bằng một đối tượng
refvar2 = refvar1;          // refvar1, refvar2 cùng tham chiếu một đối tượng

refvar1 = null;             // refvar1 gán bằng null =>  không trỏ đến đối tượng nào
refvar2.ShowData();         // refvar2 có trỏ đến đến tượng, nên có thể truy cập các thành viên của đối tượng
refvar1.ShowData();         // refvar1 không trỏ đến đối tượng nào, nên truy cập thành viên sẽ lỗi

int myvar = 10;             //  int là kiểu tham trị, nó có thể gán giá trị cho biến myvar (10)
int myvar = null;           //  lỗi - kiểu tham  trị  không được gán null hay bằng tham chiếu đến đến tượng

Sử dụng nullable trong C#
Nếu bạn muốn sử dụng các kiểu dữ liệu nguyên tố như int, float, double ... như là một kiểu dữ liệu dạng tham chiếu, có thể gán giá trị null cho nó, có thể sử dụng như đối tượng ... 
thì khai báo nó có khả năng nullable, khi biến nullable có giá trị thì đọc giá trị bằng truy cập thành viên .Value, cách làm như sau:

int? bienkieuint;                 // Hoặc Nullable<int> bienkieuint;
bienkieuint = null;               // có thể gán null cho biến
bienkieuint = 10;                 // có thể gán giá trị cho biến

if (bienkieuint != null)
{
    int val = bienkieuint.Value;  // đọc giá trị trong biến nullable
}


43 .Func và Action
Func và Action là hai mẫu delegate định nghĩa sẵn, giúp bạn nhanh chóng tạo ra biến kiểu delegate mà không mất công khai báo
Func là mẫu delegate có kiểu trả về. Để khai báo biến delegate dùng cú pháp như sau:
Func<kiểu_tham_số_1, kiểu_tham_số_2, ..., kiểu_trả_về> var_delegate;
Kiểu cuối cùng trong khai báo Func là kiểu trả về của hàm, có thể thiếu tham số nhưng không được thiếu kiểu trả về
Ví dụ muốn có biến delegate tên bien1 tương đương với hàm có 2 tham số, tham số 1 kiểu int, tham số 2 kiểu string, và hàm trả về kiểu bool thì tạo biến đó như sau:
Func<int, string, bool> bien1;
Khai báo trên nếu bạn dùng cách thông thường tương ứng với:
// Khai báo delegate ở lớp
delegate bool DelegateName(int a, string b);
// Khai báo biến trong phương thức
DelegateName bien1;

Action tương tự như Func, điều khác duy nhất là nó không có kiểu trả về, khai báo cơ bản như sau:
Action<kiểu_tham_số_1, kiểu_tham_số_2, ... > var_delegate;
Nghĩa là biến kiểu Action có thể gán bằng các hàm có kiểu trả về void
public static void TestAction(string s)
{
    Action<string> showLog = null;

    showLog += Logs.Warning;         // Nối thêm Warning vào delegate
    showLog += Logs.Info;            // Nối thêm Info vào delegate
    showLog += Logs.Warning;         // Nối thêm Warning vào delegate

    // Một lần gọi thi hành tất cả các phương thức trong chuỗi delegate
    showLog("TestLog");
}


44. lambda trong C# 
Biểu thức lambda còn gọi là biểu thức hàm nặc danh (Anonymous), một biểu thức khai báo giống phương thức (hàm) nhưng thiếu tên. 
(các_tham_số) =>
{
   // các câu lệnh
    // Sử dụng return nếu có giá trị trả về
}

(int x, int y) => {
    return x + y;
};

Có thể gán biểu thức này cho biến delegate. Ví dụ:  
using System;

namespace CS09_Anonymous_lambda {
    class Program {
        public delegate int TinhToan (int a, int b);
        static void Main (string[] args) {

            // Gán biểu thức lambda cho delegate
            TinhToan tinhtong = (int x, int y) => {
                return x + y;
            };

            //Gán lambda cho Func
            Func<int, int, int> tinhtong1 = (int x, int y) => {
                return x + y;
            };
            // Gán lambda cho Action
            Action<int> thongbao = (int vl) => {
                Console.WriteLine (vl);
            };

            int kq = tinhtong (5, 1); // kq = 6;
            Console.WriteLine(kq);
        }
    }
}

Ví dụ, khai báo phương thức:

int Tong(int x, int y) => x + y;
Nó tương đương với dạng đầy đủ đã biết

int Tong(int x, int y)
{
    return x + y;
}

45. Các phương thức mở rộng trong C# C Sharp 
https://www.youtube.com/watch?v=5gPIMxuF6Yw&list=PLwJr0JSP7i8BERdErX9Ird67xTflZkxb-&index=23
Kỹ thuật dùng hàm mở rộng để bổ sung các tính năng cho thư viện sẵn có được dùng rất nhiều trong thư viện LINQ - để mở rộng chức năng cho các IEnumerable

Xem ví dụ sau:

using System.Collections.Generic;

namespace CS020_ExtensionMethod
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> ls = new List<int>() {1,2,3,4};
            var ps = ls.Where(i => i >= 3);             // Lỗi vì List không có phương thức Where
        }
    }
}
Giờ sửa lại code như sau:

using System.Collections.Generic;
using System.Linq;                                      // Nạp thư viện LINQ

namespace CS020_ExtensionMethod
{
    class Program
    {
        static void Main(string[] args)
        {
            List<int> ls = new List<int>() {1,2,3,4};
            var ps = ls.Where(i => i >= 3);             // Linq đã mở rộng thêm vào List phương thức Where
        }
    }
}


Khai báo phương thức mở rộng
Tham số đầu tiên của hàm là kiểu string (lớp mà phương thức mở rộng sẽ thêm vào) cho thêm từ khóa this vào phía trước kiểu này - để cho biết sẽ mở rộng lớp string với phương thức này.
public static class MyExtensionMethods {
     public static void Print(this string s, ConsoleColor color = ConsoleColor.Yellow)
     {
         ConsoleColor lastColor = Console.ForegroundColor;
         Console.ForegroundColor = color;
         Console.WriteLine(s);
         Console.ForegroundColor = lastColor;
     }
}

46.Phương thức tĩnh, dữ liệu chỉ đọc, quá tải toán tử và indexer trong lập trình C# 
- Phương thức tĩnh ko thuộc lớp dù khai báo trong lớp gọi luôn ko cần dùng new
VD:
class A {
    public static void In(){
        WriteLine("ssss");
    }
}

class B{
    main{
        A.In(); // Không cần new A
    }
}

Dữ liệu chỉ đọc : readonly
 - Chỉ được gán lại bởi phương thức khởi tạo
 class student {
    public readonly string name;  //public readonly string name = "Khoi tao"

    public student( _name ) {
        name = _name; 
    }
 }

Quá tải toán tử : Viết lại toán tử
VD Syntax : public static MyVector operator+(MyVector a, MyVector b){//...logic}
class MyVector {
    double x;
    double y;
    public MyVector(double x, double y)
    {
        this.x = x;
        this.y = y;
    }
    public void ShowXY() {
        Console.WriteLine("x = " + x);
        Console.WriteLine("y = " + y);
    }
    public static MyVector operator+(MyVector a, MyVector b){
        double sx = a.x + b.x;
        double sy = a.x + b.y;
        MyVector v = new MyVector(sx,sy);
        return v;
    }
    public static MyVector operator+(MyVector a, double b){
        double sx = a.x + b;
        double sy = a.x + b;
        MyVector v = new MyVector(sx,sy);
        return v;
    }

}

Bộ đánh chỉ mục indexer trong C# :
public double this [int i] { // Có thể chỉ số là chuỗi public double this [string s]
    set{
        switch(i){
            case 0:
                x=value;
            break;
            case 1 :
                y = value;
            break;
            default :
                throw new Exception("Chi so sai);
        }
    }
    get {
        switch(i){
            case 0:
                return x;
            break;
            case 1 :
                return y;
            default :
                throw new Exception("Chi so sai);
        }
    }
}

47. Ngoại lệ Exception
- Nếu ngoại lệ (lỗi thực thi) phát sinh mà không xử lý thì chương trình sẽ dừng đột ngột - nếu muốn xử lý ngoại lệ thì ta cần bắt lấy nó và điều hướng chương trình một cách thích hợp.
try {
   // Các khối code được giám sát để bắt lỗi nếu có
   // nếu có lỗi sẽ phát sinh ngoại lệ Exception
   // Ngoại lệ này bắt lại được ở khối catch
}
catch (Exception loi)
{
  // Khối này thực thi khi có lỗi - đối tượng Exception bắt được lưu ở biến loi
}
catch(Exception e){
    // Thêm lỗi
    Console.WriteLine(e.GetType().name) ; // Viết ra tên lỗi Exception
}
finally { // Có thể bỏ qua khối này
    // Luôn được thi hành dù có phát sinh ngoại lệ hay không
    Console.WriteLine(z);
}

- Đối tượng lớp Exception có một số thuộc tính, tiện dụng cho bạn gỡ rối đó là:
Message chuỗi chứa nội dung thông báo lỗi
StackTrace chuỗi chứa các bước thực thi chương trình cho đến khi bị lỗi (có chứa các phương thức, hàm khi thực thi gây lỗi, vị trí file lỗi ...)
Source chứa tên ứng dụng hoặc đối tượng bị lỗi

if( ... ){
    Exception e = new Exception ("tên phải khác rỗng")
    throw e;
    // Hoặc throw new Exception("Tuoi phai lon hon 18")
}

Tạo Exeption riêng :
Tạo thử một lớp đặt tên là DataTooLongExeption như sau:

using System;
namespace CS015_Error_Exception
{
    public class DataTooLongExeption : Exception
    {
        const string erroMessage = "Dữ liệu quá dài";
        public DataTooLongExeption() : base(erroMessage) {
        }
    }
}

Exception e = new DataTooLongExeption();

48. Chuỗi str trong C# bổ sung
using System.String

Chuỗi nhập vào viết trong cặp nháy kép "", chèn vào chuỗi các ký tự đặc biệt ta dùng ký hiệu \: ví dụ \\ là ký tự \, \" là ký tự ", \n là ký tự xuống dòng, \r là ký tự về đầu dòng ...
string s = "C:\\Abc\\xyz";
// Nếu viết string s = "C:\Abc\xyz"; sẽ lỗi

Nếu muốn viết chuỗi cố định, nội dung nguyên bản - cho biết sẽ không dùng \ để xử lý ký tự đặc biệt, thì thêm @ vào đầu chuỗi:
string s = @"Ký tự \ được dùng để chèn ký tự đặc biệt như \n, \r";
string s = @"Anh ấy nói ""Đây là C#"""; //~ Anh ấy nói "Đây là C#";
Ngoài ra bạn có thể viết chuỗi trên nhiều dòng với ký hiệu @
string s = @"Xin chào các bạn
             Tôi đang học C#";


Chèn thêm biểu thức vào chuỗi với ký hiệu $ trong C# :
int a = 10;
int b = 2;
string s = $"Kết quả {a}/{b} là {a/b}";  // "Kết quả 10/2 là 5"
Ký hiệu {i,10} là để ra một khoảng trống 10 ký tự, chèn giá trị i vào khoảng trống đó với căn lề bên phải. 
Ký hiệu {chanle, -5} là đề ra 5 khoảng trống chèn giá trị và căn lề trái.

49. Làm việc với File
- Đọc thông tin ổ đĩa - DriveInfo :
using System.IO;
Phương thức DriveInfo.GetDrives() trả về mảng gồm các đối tượng DriveInfo, mỗi đối tượng chứa thông tin về một ổ đĩa. 
DriveInfo Drive = new DriveInfo("C");
var ListDrive = DriveInfo.GetDrives();
foreach (var i in ListDrive){
    Console.WriteLine(i.Name);
    Console.WriteLine(i.DriveType);
    Console.WriteLine(i.TotalSize);
    Console.WriteLine(i.AvailableFreeSpace);
    Console.WriteLine("---------------------------");
}

- Làm việc với lớp Directory : Lớp System.IO.Directory cung cấp các phương thức chuyên tương tác với các thư mục.
using System.IO.Directory;
Exists(path)	Kiểm tra xem thư mục có tồn tại (true) hay không (false)
CreateDirectory(path)	Tạo thư mục, trả về đối tượng System.IO.DirectoryInfo chứa thông tin thư mục.
Delete(path)	Xóa thư mục.
GetFiles(path)	Lấy các file trong thư mục.
GetDirectories(path)	Lấy các thư mục trong thư mục.
Move(src, des)	Di chuyển thư mục.


- Lớp Path(Lớp Tĩnh) Hỗ trợ làm việc với đường dẫn : Để hỗ trợ quản lý, tạo các đường dẫn đến file, thư mục - nhất là hỗ trợ cross-platform thì lớp tĩnh System.IO.Path chứa các phương thức (tĩnh) với mục đích đó.
Path.Phương Thức;
Path.DirectorySeparatorChar	Thuộc tính chứa ký tự phân cách đường dẫn thư mục (\ trên Windows, / trên *nix)
Path.PathSeparator	Thuộc tính chứa ký tự phân chia thư mục trong biến môi trường
Combine	Kết hợp các chuỗi thành dường dẫn
var path = Path.Combine("home", "ReadMe.txt"); //  "home/ReadMe.txt"
ChangeExtension	Thay đổi phần mở rộng của đường dẫn
var path = Path.ChangeExtension("/home/abc/ReadMe.txt", "md"); //  "/home/abc/ReadMe.md"
GetDirectoryName	Lấy đường dẫn đến file (thư mục)
var path = Path.GetDirectoryName("/home/abc/zyz/ReadMe.txt"); //  "/home/abc/zyz"
GetExtension	Lấy phần mở rộng
var path = Path.GetExtension("/home/ReadMe.txt"); //  ".txt"
GetFileName	Lấy tên file
var path = Path.GetFileName("/home/abc/ReadMe.txt"); //  "ReadMe.txt"
GetFileNameWithoutExtension	Lấy tên file
var path = Path.GetFileNameWithoutExtension("/home/ReadMe.txt"); //  "ReadMe"
GetFullPath	Lấy đường dẫn đầy đủ - từ đường dẫn tương đối
var path = Path.GetFullPath("ReadMe.txt");
GetPathRoot	Lấy gốc của đường dẫn
GetRandomFileName	Tạo tên file ngẫu nhiên
var path = Path.GetRandomFileName();
GetTempFileName	Tạo file duy nhất, rỗng
var path = Path.GetTempFileName();

- Lớp file Nó có nhiều phương thức cho những mục đích khác nhau như :
+ File class, như copy, xóa, di chuyển, lưu text vào file, đọc nội dung file, kiểm tra sự tồn tại, tra cứu thông tin về file ...
using  System.IO.File;
File.Phương Thức

Tìm hiểu về luồng stream, sử dụng luồng FileStream để đọc ghi file, kỹ thuật đọc ghi copy file text khi sử dụng FileStream trong lập trình C#
Một luồng (stream) là một đối tượng được sử dụng để truyền dữ liệu. 
Khi dữ liệu truyền từ các nguồn bên ngoài vào ứng dụng ta gọi đó là đọc stream, và khi dữ liệu truyền từ chương trình ra nguồn bên ngoài ta gọi nó là ghi stream.
Thư viện .NET cung cấp lớp cơ sở System.IO.Stream để hỗ trợ làm việc đọc ghi các byte dữ liệu với các stream, từ lớp cơ sở này một loạt lớp kế thừa cho những stream đặc thù như: FileStream, BufferStream, MemoryStream ...

Stream stream = new MemoryStream (); // var stream = new MemoryStream ();
var stream = new FileStream( path:filepath, mode: FileMode.Open, access: FileAccess.ReadWrite, share: FileShare.Read)

using System.IO.Stream;

Lớp FileStream tạo ra các đối tượng để đọc và ghi dữ liệu ra file.  cần đưa nó vào cấu trúc using để tự động gọi giải phóng tài nguyên (Dispose) khi hết khối lệnh.
string filepath = "/home/data/data.txt";
using (var stream = new FileStream(path:filepath, mode: FileMode.Open, access: FileAccess.Read, share: FileShare.Read))
{
    // code sử dụng stream (System.IO.Stream)
}

50. Interface IDisposable và từ khóa using
- Interface IDisposable : System.IDisposable
Giao diện này chỉ có định nghĩa một phương thức: public void Dispose (); các thao tác để giải phóng các tài nguyên chiếm giữ - khi đối tượng bị hủy
Các loại tài nguyên đặc biệt : 
Mở file - stream
Các kết nối mạng, kết nối đến CSDL ...
Những vùng bộ nhớ không quản lý được, các font chữ ...
Bạn cần viết code giải phóng tài nguyên thích hợp ở phương thức hủy (Finalize) và có thể là triển khai giao diện IDisposable để sử dụng với câu lệnh using

Câu lệnh using :
using (obj_1, obj_2 ... obj_n) {
    //các câu lệnh trong Using
}
obj_1, obj_2 ... là các đối tượng của những lớp triển khai giao diện IDisposabe

Hãy thử ví dụ sau:

Lớp A triển khai giao diện IDisposable
class A : IDisposable {
    bool resource = true;
    public void Dispose() {
        Console.WriteLine("Phương thức này gọi tự động khi hết using");
        resource = false; // giải phóng tài nguyên
    }
}
Sử dụng Using với lớp trên
using (var a = new A()) {
    Console.WriteLine("Do something ...");
}

Chạy code trên - kết quả là:
Do something ...
Phương thức này gọi tự động khi hết using

51. 