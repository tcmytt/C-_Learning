C# nền Console Application

1. C# là gì?
C# là một ngôn ngữ lập trình thuần hướng đối tượng được phát triển bởi Microsoft.
Được xây dựng dựa trên nền tảng của 2 ngôn ngữ lập trình mạnh nhất đó là C++ và Java. 
C# với sự hỗ trợ mạnh mẽ của .NET Framework giúp cho việc tạo một ứng dụng Windows Forms hay WPF (Windows Presentation Foundation), . . . trở nên rất dễ dàng.

2.Cấu trúc lệnh cơ bản trong C# Console Application

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Cau_Truc_Lenh_Co_Ban
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }
}


- using <tên thư viện>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

- Namespace : 
namespace <tên namespace>{
    // Các thành phần bên trong namespace bao gồm các lớp, enum, delegate hoặc các
    // namespace con
 }

VD: namespace Cau_Truc_Lenh_Co_Ban{
    public class Action { }
    public delegate void Art();
    namespace Sub_Namespace { }
}
- comment
Ctrl + K + C: đóng comment đoạn code 
Ctrl + K + U: để mở đoạn comment

3. Nhập xuất cơ bản trong C# Console Application
- Console.Write();
Cú pháp: Console.Write(<giá trị cần in ra màn hình>);
Ý nghĩa: In giá trị ra màn hình console. Giá trị này có thể là 1 ký tự, 1 chuỗi, một giá trị có thể chuyển về kiểu chuỗi

- Console.WriteLine();
Cú pháp: Console.WriteLine(<giá trị cần in ra màn hình>);
Ý nghĩa: In giá trị ra màn hình xong nó sẽ tự động đưa con trỏ xuống dòng.
C1: Console.WriteLine(“K team”)  
C2: Console.Write (“K team \n”) 
C3: Environment.NewLine

int a = 5; 
Console.Write("a =  “ + a); // Kết quả màn hình là: a = 5
In ra giá trị của biến: Console.Write("{0} {1} {2} {...}", <giá trị 0>, <giá trị 1>, <giá trị 2>, <giá trị n>);
Console.Write("a = {0}", a); // In ra màn hình giá trị "a = 5".

- Console.Read();
VD: Console.WriteLine(Console.Read());
Đọc 1 ký tự từ bàn phím và trả về kiểu số nguyên (sẽ được trình bày chi tiết ở bài KIỂU DỮ LIỆU TRONG C#) là mã ASCII
Chú ý: lệnh này không đọc được các phím chức năng như Ctrl, Shift, Alt, Caps Lock, Tab, . . .

- Console.ReadLine();
VD: Console.WriteLine(Console.ReadLine());
Ý nghĩa: Đọc dữ liệu từ bàn phím cho đến khi gặp ký tự xuống dòng thì dừng (Nói cách khác là đọc cho đến khi mình nhấn enter thì dừng) và giá trị đọc được luôn là một chuỗi.

- Console.ReadKey(<tham số kiểu bool>)
Lệnh này cũng dùng để đọc một ký tự từ bàn phím nhưng trả về kiểu ConsoleKeyInfo (là một kiểu dữ liệu có cấu trúc được định nghĩa sẵn để chứa những ký tự của bàn phím bao gồm các phím chức năng).

4. Kiểu dữ liệu 
Kiểu dữ liệu giá trị (value): bool, byte, char, decimal, double, enum, float, int, long, sbyte, short, struct, uint, ulong, ushort.
Kiểu dữ liệu tham chiếu (reference): object, dynamic, string và tất cả các kiểu dữ liệu do người dùng định nghĩa.
Giá trị của kiểu char sẽ nằm trong dấu ‘ ’ (nháy đơn).
Giá trị của kiểu string sẽ nằm trong dấu “ ” (nháy kép).
Giá trị của biến kiểu float phải có chữ F hoặc f làm hậu tố.
Giá trị của biến kiểu decimal phải có chữ m hoặc M làm hậu tố.
Trừ kiểu string, tất cả kiểu dữ liệu trên đều không được có giá trị null

strSoNguyen = Console.ReadLine(); // Đọc dữ liệu nhập vào từ bàn phím (dữ liệu này ở dạng chuỗi) sau đó gán giá trị vào biến strSoNguyen
SoNguyen = Int32.Parse(strSoNguyen); // Ép kiểu dữ liệu vừa nhập vào (dạng chuỗi) sang dạng số rồi gán giá trị vào biến SoNguyen
KetQua = (SoNguyen % 2 == 0) ? "so chan" : "so le"; // Sử dụng toán tử 3 ngôi để kiểm tra số chẵn lẻ

5. Hằng trong C#
const <kiểu dữ liệu> <tên biến> = <giá trị hằng>;
Kiểu liệt kê(ENUM) là tập hợp các tên hằng có giá trị không thay đổi.
- (<kiểu dữ liệu>) <biến cần ép kiểu>
int i = 300; // 300 có mã nhị phân là 100101100
byte b = (byte)i; 
double d = 2 / 3; // kết quả ra 0 vì 2 và 3 đều là số nguyên nên thực hiện 2 chia lấy phần nguyên với 3 được 0
double k = (double)2 / 3; // Ép kiểu số 2 từ kiểu nguyên sang kiểu số thực. Như vậy kết quả phép chia sẽ ra số thực
double t = 1.0 * 2 / 3; 

- <kiểu dữ liệu>.Parse(<dữ liệu cần chuyển đổi>); Chuyển đổi một chuỗi sang một kiểu dữ liệu cơ bản tương ứng.
string stringValue = "10";
int intValue = int.Parse(stringValue); // Chuyển chuỗi stringValue sang kiểu int và lưu giá trị vào biến intValue - Kết quả intValue = 10
double HowKteam = double.Parse("10.9"); // Chuyển chuỗi giá trị hằng "10.9" sang kiểu int và lưu giá trị vào biến HowKteam - Kết quả HowKteam = 10.9

- <kiểu dữ liệu>.TryParse(<dữ liệu cần chuyển đổi>, out <biến chứa kết quả>); Chuyển một chuỗi sang một kiểu dữ liệu cơ bản tương ứng.
Phương thức sẽ trả về true nếu chuyển kiểu thành công và giá trị kết quả chuyển kiểu sẽ lưu vào <biến chứa kết quả>. Ngược lại sẽ trả về false và <biến chứa kết quả> sẽ mang giá trị 0.
bool isSuccess; // Biến kiểm tra việc ép kiểu có thành công hay không
string Data1 = "10", Data2 = "Kteam"; // Dữ liệu cần ép kiểu
isSuccess = int.TryParse(Data1, out Result);

-Ngoài TryParse() ra thì vẫn có một cách ép kiểu không báo lỗi chương trình. Đó là sử dụng toán tử as:
Trong bài TOÁN TỬ TRONG C# chúng ta có giới thiệu toán tử as dùng để “Ép kiểu mà không gây ra lỗi. Nếu ép kiểu không thành công sẽ trả về null”.

- Convert()
gõ “Convert.” (lưu ý dấu chấm liền sau Convert) Visual Studio sẽ hiển thị ra tất cả các phương thức có trong lớp Convert. 
Giờ bạn chỉ việc lựa chọn phương thức muốn sử dụng là được.
VD: String str = Convert.ToBase64String(B); 
Các trường hợp tham số truyền vào sai định dạng hoặc vượt quá giới hạn thì chương trình sẽ báo lỗi như phương thức Parse().

6. Kiểu dữ liệu Object trong C#
- Thuộc kiểu dữ liệu tham chiếu, Mọi kiểu dữ liệu đều được kế thừa từ System.Object

- Boxing là quá trình chuyển dữ liệu từ kiểu dữ liệu giá trị sang kiểu dữ liệu tham chiếu.
VD:    int Value = 109; 
    object ObjectValue = Value; 

- Unboxing là quá trình ngược lại với boxing, tức là đưa dữ liệu từ kiểu dữ liệu tham chiếu về kiểu dữ liệu giá trị.
VD: int NewValue = (int)ObjectValue; 

- Từ khóa var trong C# :  
Bắt buộc phải gán giá trị ngay khi khởi tạo biến và không thể khởi tạo giá trị null cho biến var.
var chỉ là từ khóa dùng để khai báo biến không phải là một kiểu dữ liệu.
VD: 
var varLong = 109;
var varString = null; // lỗi

7. Từ khóa Dynamic trong C#
Khai báo : dynamic <tên biến>;
Từ khóa dynamic là từ khóa dùng để khai báo kiểu dynamic. Kiểu dynamic là một khái niệm mới được đưa vào trong C# 4.0.
Các đối tượng thuộc kiểu dynamic sẽ không xác định được kiểu cho đến khi chương trình được thực thi. 
Tức là trình biên dịch sẽ bỏ qua tất cả lỗi về cú pháp, việc kiểm tra này sẽ thực hiện khi chương trình thực thi.
Có thể ép kiểu qua lại với các kiểu dữ liệu khác một cách bình thường 

VD1:
// Khai báo biến StringValue kiểu dynamic và khởi tạo giá trị là một chuỗi kiểu string
dynamic StringValue = "HowKteam";
/* 
* Chúng ta biết rằng kiểu chuỗi không hỗ trợ toán tử ++
* Nhưng câu lệnh StringValue++ vẫn không báo lỗi là do ở thời điểm hiện tại trình biên dịch vẫn chưa xác định kiểu dữ liệu cho biến StringValue
* Khi chạy chương trình thì lúc này C# mới phát hiện biến StringValue là kiểu string và không thể thực hiện toán tử ++ lúc đó sẽ xuất hiện lỗi
*/
StringValue++;

VD2:
// Khai báo 2 biến Name và Mission kiểu string và khởi tạo giá trị.
string Name = "HowKteam ";
string Mission = "Free Education";
/* 
 * Thực hiện gán 1 biến kiểu string cho biến kiểu dynamic bằng cách ép kiểu ngầm định (implicit)
 * Sau phép gán này thì biến DynamicValue chứa giá trị là "Free Education" nhưng kiểu dữ liệu của nó vẫn chưa được xác định.
*/
dynamic DynamicName = Name;

// Thực hiện cộng chuỗi và in ra màn hình bình thường
Console.WriteLine("Mission of " + DynamicName + " is " + Mission);


Phân biệt object, var và dynamic
- object là kiểu dữ liệu , var và dynamic là từ khoá
- object và dynamic sử dụng để làm kiểu trả về hoặc tham số cho hàm;
- object và dynamic có khả năng ép kiểu qua lại với các kiểu dữ liệu khác 
- var xác định ngay khai báo, dynamic lúc thực thi

8. goto
Vòng lặp For
Vòng lặp While
Vòng lặp Do While
Vòng lặp Foreach

Vòng lặp goto
cấu trúc : 
    label:
    goto label;

static void Main(string[] args){
    int a = 1;
    if (a == 2)
    {
        // dịch chuyển tới vị trí label a_Is_2
        goto a_Is_2;
    }
    Console.WriteLine("A == 1");
    a_Is_2:
    Console.WriteLine("A == 2");
    Console.ReadKey();
}
 
9.Cấu trúc của hàm cơ bản trong C#
[Từ khóa 1] [Từ khóa 2] [Từ khóa n]  <Kiểu dữ liệu trả về> <Tên hàm>([Parameter]){ }
- [Từ khóa 1], [Từ khóa 2], [Từ khóa n] là các từ khóa như: public, static, read only … và có thể không điền.
- Kiểu dữ liệu trả về như: từ khóa void, hay mọi kiểu dữ liệu như int, long, bool, SinhVien…
- Parameter là tham số truyền vào để sử dụng nội bộ trong hàm. Cấu trúc khởi tạo như một biến bình thường. Có thể không điền.
- Hàm chỉ được khai báo bên trong class.

10. Biến
class Program {
        static int value = 5;
        static void Main(string[] args)  {
            Console.WriteLine(value); // 5
            value = 10;
            PrintSomeThing();
            Console.ReadKey();
        }
        static void PrintSomeThing() {           
            Console.WriteLine(value); // 10
        }
    }

11. Từ khóa ref và out trong C#
- Từ khóa ref
ref hơi giống & trong c++ truyền vào tác dụng thay đổi giá trị gốc khi được gọi hàm
Từ khóa ref phải có trước tên parametter của hàm và trước tên biến truyền vào khi gọi hàm sử dụng.
Truyền parameter có từ khóa ref bắt buộc phải là một biến (không thể truyền vào một hằng vì hằng là giá trị không thay đổi).
Có thể có một hoặc nhiều parameter với từ khóa ref trong lời khai báo hàm.
Biến truyền vào có từ khóa ref thì phải được khởi tạo giá trị trước khi truyền vào.
Hàm sử dụng sẽ thao tác trực tiếp với vùng nhớ của các parameter trên RAM. Cho nên kết thúc lời gọi hàm giá trị các parameter sẽ bị thay đổi.
VD:static void Main(string[] args){
           int value = 5;
           Console.WriteLine("Value before increase: {0}", value);
           IncreaseValue(ref value);
           Console.WriteLine("Value after increase: {0}", value);
           Console.ReadKey();
        }
        static void IncreaseValue(ref int value){
            value++;
        }

- Từ khóa out
Từ khóa out cũng tương tự từ khóa ref. Đó là:
Vùng nhớ của các parameter sẽ được hàm sử dụng thao tác trực tiếp, dẫn đến khi kết thúc lời gọi hàm giá trị của các parametter có thể bị thay đổi.
 Phải có từ khóa out trước tên parameter của hàm và trước tên biến truyền vào khi gọi hàm sử dụng.

Nhưng có một sự khác biệt đó là:
 Biến truyền vào có từ khóa out sẽ không cần khởi tạo giá trị ban đầu.
 Parameter đó chỉ như một thùng chứa kết quả trả về khi kết thúc gọi hàm.
 Đồng thời parameter đó phải được khởi tạo ngay bên trong lời gọi hàm.

 12. Mảng
- Mảng 1 chiều :
 <kiểu dữ liệu>[] <tên mảng> = new <kiểu dữ liệu>[] { <giá trị 1>, …, <giá trị n> };
 VD:
 string[] Kteam = new string[3];
 int[] IntArray = { 3, 9, 10 };
 string[] Kteam = new string[] { "HowKteam", "Free Education" };

- Mảng 2 chiều :
<kiểu dữ liệu> [ , ] <tên mảng>;
VD:
string[,] Kteam = new string[2, 3]; // số dòng là 2 và số cột là 3.
int[,] IntArray = 
{ 
    {1, 2}, 
    {3, 4}, 
    {5, 6} 
};
string[,] Kteam = new string[,] 
{
{ "HowKteam", "Free Education" },
{ “HowKteam.com”, “Share to be better” }
}; 

Phương thức :
.length(); .Clone();

- Mảng jagged trong C# : 
Không giống như mảng 2 chiều, mảng jagged không cho phép cấp phát cùng lúc số dòng và số cột 
mà phải cấp phát số dòng trước sau đó ứng với mỗi dòng ta cấp phát số cột theo ý muốn.
<kiểu dữ liệu> [ ][ ] <tên mảng>;
VD:  int [][] JaggedArray = new int[3][];
     JaggedArray[0] = new int[3];
     JaggedArray[1] = new int[9];
     JaggedArray[2] = new int[10];

int[][] JArray ={
    new int[] {1, 2, 3},
    new int[] {3, 4, 5, 6, 7, 8, 9}
};
Sử dụng <tên mảng>[i][j] thay vì <tên mảng>[i, j].

- Lớp Array trong C# :
Lớp Array trong C# là lớp cơ sở cho mọi mảng, một mảng bất kỳ đều được kế thừa từ lớp này
Array.Sort(<tên mảng>)
Array.Reverse(<tên mảng>)
Array.IndexOf(<tên mảng>, <phần tử cần tìm>)

13. Vòng lặp foreach trong lập trình C#
Một số đặc trưng của foreach:
Foreach không duyệt mảng hoặc tập hợp thông qua chỉ số phần tử như cấu trúc lặp for.
Foreach duyệt tuần tự các phần tử trong mảng hoặc tập hợp.
Foreach chỉ dùng để duyệt mảng hoặc tập hợp ngoài ra không thể làm gì khác.

foreach (<kiểu dữ liệu> <tên biến tạm> in <tên mảng hoặc tập hợp>)
{
  // Code xử lý        
}

Trong C#, có những danh sách, tập hợp mà ta không thể truy xuất đến các phần tử của nó thông qua chỉ số phần tử được 
Trong trường hợp như vậy, để duyệt các danh sách, tập hợp có tính chất như trên thì foreach là lựa chọn tốt nhất.

foreach (int item in IntArray)
{
    Console.Write("\t" + item);
    Sum += item;
}

14. String
String là một kiểu dữ liệu tham chiếu được dùng để lưu trữ chuỗi ký tự. 
Một số phương thức thường dùng trong lớp String:
String.Compare(strA, strB) ; 0 | 1 | -1
String.Concat(strA, strB) ; // Nối chuỗi
String.IsNullOrEmpty(strA) ; 

strA.Substring(3, 1);
Chuẩn hoá tên :
for (int i = 0; i < SubName.Length; i++)
            {
                SubName[i] = SubName[i].Substring(0, 1).ToUpper() +SubName[i].Substring(1).ToLower();
                Result += SubName[i] + " ";
            }

- Lớp StringBuilder trong C# : được .NET xây dựng sẵn giúp chúng ta thao tác trực tiếp với chuỗi gốc và giúp tiết kiệm bộ nhớ hơn so với lớp String.
Cho phép thao tác trực tiếp trên chuỗi ban đầu.
Có khả năng tự mở rộng vùng nhớ khi cần thiết.
Không cho phép lớp khác kế thừa

Khởi tạo một đối tượng rỗng:
StringBuilder <tên biến> = new StringBuilder();
Khởi tạo một đối tượng chứa 1 chuỗi cho trước:
StringBuilder <tên biến> = new StringBuilder(<chuỗi giá trị>);

VD: StringBuilder MutableValue = new StringBuilder("How");
 MutableValue.Append("Kteam");
Trong lớp StringBuilder có các phương thức như: Remove, Insert, Replace được sử dụng hoàn toàn giống như lớp String.
Mới : Append(string value); Clear(); ToString()
Các bạn nhớ đây là đối tượng kiểu StringBuilder nên thao tác với chuỗi như gán, nối chuỗi, . . . phải thông qua các phương thức chứ không thể thực hiện trực tiếp được.

Thông thường đối với các bài toán đòi hỏi thao tác nhiều với chuỗi gốc như cộng chuỗi, chèn chuỗi, xoá bỏ một số ký tự, . . . thì nên sử dụng StringBuilder để tối ưu bộ nhớ.
 Còn lại thì nên sử dụng String để việc thao tác thuận tiện hơn.

15. struct
Struct là một kiểu dữ liệu có cấu trúc, được kết hợp từ các kiểu dữ liệu nguyên thuỷ do người lập trình định nghĩa để thuận tiện trong việc quản lý dữ liệu và lập trình.
Là một kiểu dữ liệu tham trị , Bên trong struct ngoài các biến có kiểu dữ liệu cơ bản còn có các phương thức, các struct khác.
Muốn sử dụng phải khởi tạo cấp phát vùng nhớ cho đối tượng thông qua toán tử new. 

struct SinhVien
{
public int MaSo;
public string HoTen;
public double DiemToan;
public double DiemLy;
public double DiemVan;

}

static void NhapThongTinSinhVien(out SinhVien SV)
        {
            Console.Write(" Ma so: ");
            SV.MaSo = int.Parse(Console.ReadLine());
            Console.Write(" Ho ten: ");
            SV.HoTen = Console.ReadLine();
            Console.Write(" Diem toan: ");
            SV.DiemToan = Double.Parse(Console.ReadLine());
            Console.Write(" Diem ly: ");
            SV.DiemLy = Double.Parse(Console.ReadLine());
            Console.Write(" Diem van: ");
            SV.DiemVan = Double.Parse(Console.ReadLine());
        }

16. Enum trong lập trình C#
Enum là từ khoá dùng để khai báo một kiểu liệt kê (Enumeration). Kiểu liệt kê là một tập hợp các hằng số do người dùng tự định nghĩa.
Là một kiểu dữ liệu tham trị, Enum không được phép kế thừa
enum <tên enum>{
    <danh sách các biểu tượng hằng>
}
<tên enum> là tên kiểu liệt kê do mình tự đặt và tuân thủ theo quy tắc đặt tên (đã trình bày trong bài BIẾN TRONG C#).
<danh sách các biểu tượng hằng> là danh sách các biểu tượng hằng thành phần mỗi biểu tượng hằng cách nhau bằng dấu “,”.

    public const int RED = 0;
    public const int BLUE = 1;
    public const int YELLOW = 2;
Tương đương : Đại diện 0,1,2
enum Color{
    RED,
    BLUE,
    YELLOW
}
Hoặc :
enum Color{
    RED = 2,
    BLUE = 4,
    YELLOW = 6,
}
Nếu ta không quy định giá trị cho các biểu tượng hằng thì giá trị của biểu tượng hằng đầu tiên sẽ mặc định là 0 và tăng dần cho các biểu tượng hằng tiếp theo.
Ta có thể truy xuất đến từng biểu tượng hằng của enum thông qua toán tử “.” Kèm theo tên biểu tượng hằng muốn truy xuất.
VD: Color.RED;
Mặc dù bản chất các biểu tượng hằng là đại diện cho các số nguyên nhưng bạn không thể so sánh trực tiếp chúng với các số nguyên được mà phải ép kiểu
2 == (int)Color.RED;
Color Background = (Color)6; // Background sẽ có giá trị là Color.YELLOW

17. Regular Expression trong C#
Regular Expression hay tiếng Việt được gọi là Biểu thức chính quy, là một cấu trúc rất mạnh để mô tả một chuỗi theo cách thống nhất chung.
Regular Expression bao gồm tập hợp các ký tự, toán tử hay ký hiệu toán học nhằm biểu thị một chuỗi theo cấu trúc chung mà mọi người học theo. 
- Dùng phần mềm RegEx tester để học

                    Tổng quan về lập trình hướng đối tượng

18. Tổng quan về lập trình hướng đối tượng
- là phương pháp lập trình dựa trên kiến trúc lớp (class) và đối tượng (object).

- Đối tượng : đối tượng được hiểu như là 1 thực thể: người, vật hoặc 1 bảng dữ liệu, . . .
Một đối tượng bao gồm 2 thông tin: thuộc tính và phương thức.

- Lớp : Các đối tượng có các đặc tính tương tự nhau được gom lại thành 1 lớp đối tượng.
Bên trong lớp cũng có 2 thành phần chính đó là thuộc tính và phương thức.
Ngoài ra, lớp còn được dùng để định nghĩa ra kiểu dữ liệu mới.

Sự khác nhau giữa đối tượng và lớp :
- Lớp là một khuôn mẫu còn đối tượng là một thể hiện cụ thể dựa trên khuôn mẫu đó.
VD: Khi nói đến xe otô thì lớp chính khuôn mẫu của cái xe với các đặc trưng như có 4 bánh , 
Đối tượng chính là các chiếc xe otô cụ thể như Toyota camry, Honda city, Ford ranger.

Lập trình hướng đối tượng có 4 đặc điểm chính:
- Tính đóng gói
- Tính trừu tượng
- Tính kế thừa
- Tính đa hình

19. Class trong Lập trình hướng đối tượng
- Một class trong C# có các thành phần như:
Thuộc tính: là các thành phần dữ liệu hay còn gọi là các biến.
Phương thức: là các hàm thành phần thể hiện các hành vi của một đối tượng thuộc lớp.
Phương thức khởi tạo.
Phương thức huỷ bỏ.

- Class trong C# thực chất là một kiểu dữ liệu mới do người dùng tự định nghĩa.
Cú pháp:
class <tên lớp>{
     <Phạm vi truy cập> <Các thành phần của lớp>;
}
VD :
class Animal{
        public double Weight;
        public double Height;
        public void Run(){
            Console.WriteLine(" Animal is running. . .");
        }
}

Animal Dog = new Animal();
Dog.Weight = 2; // gán giá trị cho các thuộc tính của đối tượng
Dog.Height = 50;
Animal Cat = new Animal();
Cat.Weight = 1;
Cat.Height = 30;
Dog.Info(); // gọi phương thức của đối tượng
Cat.Info();

Phương thức khởi tạo : 
class Cat{
        public double Weight;
        public double Height;

        public Cat(){
            Weight = 800;
            Height = 10;
        }

        public Cat(int w, int h){
            Weight = w;
            Height = h;

        }
        public void Info(){
            Console.WriteLine(" Height: " + Height + " Weight: " + Weight);
        }
    }

Cat BlackCat = new Cat();
Cat WhiteCat = new Cat(1200, 30);

Phương thức huỷ bỏ :
Có tên trùng với tên lớp nhưng để phân biệt với constructor thì ta thêm dấu “~” vào trước tên lớp.
Không có kiểu trả về.
Vì bộ GC của C# có cơ chế tự động phát hiện đối tượng không còn được sử dụng nữa và thực hiện thu hồi vùng nhớ của nó nên bạn không cần phải viết tường minh việc huỷ vùng nhớ của nó. 
Việc bạn có thể làm viết những thứ bạn muốn làm khi đối tượng bị huỷ vào đây thôi!

20 . Các loại phạm vi truy cập trong Lập trình hướng đối tượng
- public, private, protected, internal, protected internal .
Nếu khai báo lớp mà không chỉ ra phạm vi cụ thể thì phạm vi mặc định là internal.
Nếu khai báo thành phần bên trong lớp mà không chỉ ra phạm vi cụ thể thì phạm vị mặc định là private.

Các thuộc tính thường sẽ có phạm vi là private. 
Các phương thức thường sẽ có phạm vi là public. 

Phương thức truy vấn, phương thức cập nhật :
Trong C#, phương thức truy xuất và phương thức cập nhật đã được nâng cấp lên thành 1 cấu trúc mới ngắn gọn hơn và tiện dụng hơn đó là property.

<kiểu dữ liệu> <tên property> {
            get { return <tên thuộc tính>; }
            set { <tên thuộc tính> = value; }
}

<kiểu dữ liệu> là kiểu dữ liệu của property. Thường sẽ trùng với kiểu dữ liệu của thuộc tính private tương ứng bên trong lớp.
<tên property> là tên do người dùng đặt và tuân theo quy tắc đặt tên đã trình bày trong bài BIẾN TRONG C#.
get, set, value là từ khoá có ý nghĩa:
 Từ khoá get tương đương với phương thức truy vấn.
 Từ khoá set tương đương với phương thức cập nhật.
 Từ khoá value đại diện cho giá trị mà người gán vào property (tương đương với tham số truyền vào của phương thức cập nhật).
<tên thuộc tính> là tên thuộc tính thực sự bên trong lớp.

VD : 
private double diemLy;
public double DiemLy
{
get { return diemLy; }
set { diemLy = value; }
}

SinhVien SV1 = new SinhVien();
SV1.DiemLy = 8; // khi gán giá trị cho property thì các câu lệnh bên trong set sẽ được thực hiện
Console.WriteLine(" Diem ly: " + SV1.DiemLy); // khi lấy giá trị của property thì các câu lệnh bên trong get sẽ được thực hiện.

Có thể viết thêm điều kiện trong get,set :
set{
    if (value <= 10 || value >= 0){
        diemLy = value;
    }
}

21. Từ khóa Static
Đôi lúc người lập trình mong muốn 1 thuộc tính nào đó được dùng chung cho mọi đối tượng (chỉ được cấp phát 1 vùng nhớ duy nhất). 
Từ đó khái niệm thành viên tĩnh ra đời.
- Đặc điểm của thành viên tĩnh:
Được khởi tạo 1 lần duy nhất ngay khi biên dịch chương trình.
Có thể dùng chung cho mọi đối tượng.
Được gọi thông qua tên lớp.
Được huỷ khi kết thúc chương trình.

- Có 4 loại thành viên tĩnh chính:
Biến tĩnh (static variable).
Phương thức tĩnh (static method).
Lớp tĩnh (static class).
Phương thức khởi tạo tĩnh (static constructor).

Biến tĩnh :
public static int Count = 0;

Phương thức tĩnh :
Hàm tĩnh được sử dụng với 2 mục đích chính:
Hàm tĩnh là 1 hàm dùng chung của lớp. Được gọi thông qua tên lớp và không cần khởi tạo bất kỳ đối tượng nào, từ đó tránh việc lãng phí bộ nhớ.
Hỗ trợ trong việc viết các hàm tiện ích để sử dụng lại.
class TienIch{
    public static long LuyThua(int CoSo, int SoMu)
        {
            long KetQua = 1;
            for (int i = 0; i < SoMu; i++){
                KetQua *= CoSo;
            }
            return KetQua;
        }
    }

Lớp tĩnh :
Chỉ chứa các thành phần tĩnh (biến tĩnh, phương thức tĩnh).
Không thể khai báo, khởi tạo 1 đối tượng thuộc lớp tĩnh.
Với 2 đặc điểm trên có thể thấy lớp tĩnh thường được dùng với mục đích khai báo 1 lớp tiện ích chứa các hàm tiện ích hoặc hằng số vì:
Ràng buộc các thành phần bên trong lớp phải là static.
Không cho phép tạo ra các đối tượng dư thừa làm lãng phí bộ nhớ.
Mọi thứ đều được truy cập thông qua tên lớp.
Ví dụ điển hình đó là lớp Math.

Phương thức khởi tạo tĩnh :
Không được phép khai báo phạm vi truy cập. Nếu cố tình làm điều này C# sẽ báo lỗi khi biên dịch.
Constructor tĩnh sẽ được gọi 1 lần duy nhất khi chương trình được nạp vào bộ nhớ để thực thi như là 1 cách để ta thiết lập một số thông số theo ý muốn trước khi có bất kỳ đối tượng nào được tạo ra.
Constructor tĩnh cũng giống phương thức tĩnh nên không thể gọi các thuộc tính không phải static.
static <tên lớp>(){
    // nội dung của constructor
}

22. Kế thừa trong Lập trình hướng đối tượng
Trong lập trình cũng vậy, kế thừa trong lập trình là cách 1 lớp có thể thừa hưởng lại những thuộc tính, phương thức từ 1 lớp khác và sử dụng chúng như là của bản thân mình.
Cho phép xây dựng 1 lớp mới từ lớp đã có.
 Lớp mới gọi là lớp con (subclass) hay lớp dẫn xuất (derived class).
 Lớp đã có gọi là lớp cha (superclass) hay lớp cơ sở (base class).
Cho phép chia sẽ các thông tin chung nhằm tái sử dụng và đồng thời giúp ta dễ dàng nâng cấp, dễ dàng bảo trì.

class Animal{
        protected double Weight;
        protected double Height;
        protected static int Legs;

        public void Info()
        {
            Console.WriteLine(" Weight: " + Weight + " Height: " + Height + " Legs: " + Legs);
        }
    }


class Cat : Animal
    {
        public Cat()
        {
            /*
                Lớp Cat kế thừa lớp Animal
                mà các thuộc tính Weight, Height, Legs có phạm vi là protected nên được phép kế thừa
                Từ đó lớp Cat có thể sử dụng mà không cần phải khai báo

             */
            Weight = 500;
            Height = 20;
            Legs = 2;
        }
    }

Cat BlackCat = new Cat();
/* Lớp Cat kế thừa phương thức Info từ lớp Animal nên đối tượng thuộc lớp Cat có thể gọi phương thức Info() */
BlackCat.Info();

Trong C#, không hỗ trợ đa kế thừa (1 lớp kế thừa từ nhiều lớp) những lại hỗ trợ thực thi nhiều interface (khái niệm về interface sẽ được trình bày trong bài INTERFACE TRONG C#).
Các thành phần của lớp cha có được kế thừa xuống lớp con hay không là do phạm vi truy cập của thành phần đó là gì.
Thành phần có phạm vi là private thì không được kế thừa.
Thành phần có phạm vi là protected, public thì được phép kế thừa.
Phương thức khởi tạo và phương thức huỷ bỏ không được kế thừa.

Phưong thức khởi tạo : Phương thức khởi tạo mặc định của lớp cha luôn luôn được gọi mỗi khi có 1 đối tượng thuộc lớp con khởi tạo. Và được gọi trước phương thức khởi tạo của lớp con.
Từ khoá base : dùng trong constructor và base.Tên_Phương_Thức_ClassCha;
class Animal
    {
        public Animal(double w, double h, int l)
        {
            Weight = w;
            Height = h;
            Legs = l;
        }
    }

class Cat : Animal
    {
        public Cat()
        {         
            Weight = 500;
            Height = 20;
            Legs = 2;
        }

        /*
            Cách gọi constructor của lớp cha thông qua từ khoá base
         */

        public Cat(double w, double h, int l) : base(w, h, l)
        {
          

        }
    }

Từ khoá new : 
Giả sử lớp Animal có phương phức tên Info(). Lớp Cat kế thừa lớp Animal nên cũng sẽ nhận được phương thức này.
Bây giờ trong lớp Cat ta cũng định nghĩa 1 phương thức tên Info(), có kiểu trả về là void và không có tham số truyền vào.
C# sẽ gọi phương thức Info() của lớp Cat định nghĩa. Đồng thời cũng đưa ra 1 cảnh báo khi biên dịch.
Trong C# có hỗ trợ từ khoá new nhằm đánh dấu đây là 1 hàm mới và hàm kế thừa từ lớp cha sẽ bị che đi khiến bên ngoài không thể gọi được.
Từ khoá này chỉ làm tường minh khai báo của hàm Info() chứ về kết quả khi chạy chương trình sẽ không có thay đổi.
VD: 
public new void Info()

{

}

Vậy có cách nào gọi hàm Info() của lớp cha được nữa không?
Câu trả lời là có nhưng chỉ có thể gọi trong nội bộ của lớp Cat mà thôi.
/* Từ khoá new chỉ định đây là 1 hàm Info mới của lớp Cat */
        public new void Info()
        {
           Console.WriteLine(" Info of Cat: ");
           base.Info(); // gọi đến hàm Info() của lớp cha
        }


Vấn đề cấp phát vùng nhớ cho đối tượng :“Một đối tượng thuộc lớp cha có thể tham chiếu đến vùng nhớ của đối tượng thuộc lớp con nhưng ngược lại thì không”.
Animal cat = new Cat();
Cat cat = new Animal ();  // Lỗi

23. Đa hình trong Lập trình hướng đối tượng
Tính đa hình là hiện tượng các đối tượng thuộc các lớp khác nhau có thể hiểu cùng 1 thông điệp theo các cách khác nhau.
Để thể hiện được tính đa hình:
Các lớp phải có quan hệ kế thừa với cùng 1 lớp cha nào đó.
Phương thức đa hình phải được ghi đè (override) ở các lớp con .

Chỉ có thể ghi đè lên phương thức virtual hoặc abstract 
Virtual là từ khoá dùng để khai báo 1 phương thức ảo (phương thức ảo là phương thức có thể ghi đè được).
Override là từ khoá dùng để đánh dấu phương thức ghi đè lên phương thức của lớp cha.

Ta cần khai báo phương thức Speak() của lớp cha là phương thức ảo (virtual).
class Animal
    {
        public virtual void Speak()
        {
            Console.WriteLine(" Animal is speaking. . .");
        }
    }



    class Cat : Animal
    {
        public override void Speak()
        {
            Console.WriteLine(" Cat is speaking. . .");
        }
    }


    class Dog : Animal
    {
        public override void Speak()
        {
            Console.WriteLine(" Dog is speaking. . .");
        }
    }

Lớp trừu tượng và phương thức thuần ảo :
Phương thức thuần ảo là 1  phương thức ảo và không có định nghĩa bên trong.
Lớp trừu tượng là lớp chứa phương thức thuần ảo.
Abstract là từ khoá dùng để khai báo 1 lớp trừu tượng hoặc 1 phương thức thuần ảo.

abstract class Animal
    {
        /*
            Khai báo phương thức thuần ảo nên không cần định nghĩa nội dung cho phương thức
         */

        public abstract void Speak();

    }

Khi kế thừa 1 lớp trừu tượng bạn bắt buộc phải override tất cả các phương thức thuần ảo nhằm đảm bảo tính hợp lệ cho chương trình.

24. Interface trong Lập trình hướng đối tượng
là 1 tập các thành phần chỉ có khai báo mà không có phần định nghĩa (giống phương thức thuần ảo)

Đặc điểm của interface :
Chỉ chứa khai báo không chứa phần định nghĩa (giống phương thức thuần ảo). Mặc dù giống phương thức thuần ảo nhưng bạn không cần phải khai báo từ khoá abstract.
Việc ghi đè 1 thành phần trong interface cũng không cần từ khoá override.
Không thể khai báo phạm vi truy cập cho các thành phần bên trong interface. Các thành phần này sẽ mặc định là public.
Interface không chứa các thuộc tính (các biến) dù là hằng số hay biến tĩnh vẫn không được.
Interface không có constructor cũng không có destructor.
Các lớp có thể thực thi nhiều interface cùng lúc (ở 1 góc độ nào đó có thể nó là phương án thay thế đa kế thừa).
Một interface có thể kế thừa nhiều interface khác nhưng không thể kế thừa bất kỳ lớp nào.

interface ISpeak
    {
        /*
            Khai báo phương thức nhưng không định nghĩa nội dung
         */
        void Speak();
    }

    class Animal : ISpeak // lớp Animal thực thi interface ISpeak
    {
        /*
            Định nghĩa nội dung cho phương thức trong interface
	Phương thức Speak() phải có phạm vi là public vì phương thức Speak() trong interface mặc định là public rồi.
         */
        public void Speak()
        {
            Console.WriteLine("Animal is speaking. . ."); 
        }
    }

Khác nhau  interface và abstract class :
interface : Dùng định nghĩa 1 khuôn mẫu, quy tắc chung
abstract class : Dùng để định nghĩa cốt lõi lớp

Vì việc thực thi interface rất giống với kế thừa nên ta hoàn toàn có thể sử dụng câu lệnh sau:
ISpeak animal = new Animal();


        hóa học lập trình C# nâng cao

25. Tổng quan về Collection trong C#
Các lớp hỗ trợ lưu trữ, quản lý và thao tác với các đối tượng một cách có thứ tự.
Các lớp này nằm trong namespace System.Collections.

Là một mảng có kích thước động:
Không cần khai báo kích thước khi khởi tạo.
Có thể tăng giảm số lượng phần tử trong mảng một cách linh hoạt.
Có thể lưu trữ một tập hợp đối tượng thuộc nhiều kiểu khác nhau.

Một số lớp Collections được sử dụng phổ biến :
- ArrayList : Lớp cho phép lưu trữ và quản lý các phần tử giống mảng.
Tuy nhiên, không giống như trong mảng, ta có thể thêm hoặc xoá phần tử một cách linh hoạt
và có thể tự điều chỉnh kích cỡ một cách tự động.

- HashTable :   Lớp lưu trữ dữ liệu dưới dạng cặp Key – Value.
Khi đó ta sẽ truy xuất các phần tử trong danh sách này thông qua Key
(thay vì thông qua chỉ số phần tử như mảng bình thường).

- SortedList : Là sự kêt hợp của ArrayList và HashTable. Tức là dữ liệu sẽ lưu dưới dạng Key – Value.
 Ta có thể truy xuất các phần tử trong danh sách thông qua Key hoặc thông qua chỉ số phần tử.
 Đặc biệt là các phần tử trong danh sách này luôn được sắp xếp theo giá trị của Key.

-  Stack : 	Lớp cho phép lưu trữ và thao tác dữ liệu theo cấu trúc LIFO (Last In First Out).

- Queue : Lớp cho phép lưu trữ và thao tác dữ liệu theo cấu trúc FIFO (First In First Out).

- BitArray : Lớp cho phép lưu trữ và quản lý một danh sách các bit.
  Giống mảng các phần tử kiểu bool với true biểu thị cho bit 1 và false biểu thị cho bit 0.
  Ngoài ra BitArray còn hỗ trợ một số phương thức cho việc tính toán trên bit.

26. ArrayList trong C#
using System.Collections;

ArrayList trong C#:
Là một Collections giúp lưu trữ và quản lý một danh sách các đối tượng theo kiểu mảng (truy cập các phần tử bên trong thông qua chỉ số index).
Rất giống mảng các object nhưng có thể thêm hoặc xoá các phần tử một cách linh hoạt và có thể tự điều chỉnh kích cỡ một cách tự động.

// khởi tạo 1 ArrayList rỗng
ArrayList MyArray = new ArrayList(); 
// khởi tạo 1 ArrayList và chỉ định Capacity ban đầu là 5
ArrayList MyArray2 = new ArrayList(5); 
/*
 * Khởi tạo 1 ArrayList có kích thước bằng với MyArray2.
 * Sao chép toàn độ phần tử trong MyArray2 vào MyArray3.
*/
ArrayList MyArray3 = new ArrayList(MyArray2);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong ArrayList.
- Capacity :  Trả về 1 số nguyên cho biết số phần tử mà ArrayList có thể chứa (sức chứa).

Phương Thức :
- Add(object Value) : Thêm đối tượng Value vào cuối ArrayList.
- AddRange(ICollection ListObject) : Thêm danh sách phần tử ListObject vào cuối ArrayList.
- BinarySearch(object Value) :Tìm kiếm đối tượng Value trong ArrayList theo thuật toán tìm kiếm nhị phân.
  Nếu tìm thấy sẽ trả về vị trí của phần tử ngược lại trả về giá trị âm. Lưu ý: là ArrayList phải được sắp xếp trước khi sử dụng hàm.
- Clear() : Xoá tất cả các phần tử trong ArrayList.
- Clone() : Tạo 1 bản sao từ ArrayList hiện tại.
- Contains(object Value) : Kiểm tra đối tượng Value có tồn tại trong ArrayList hay không.
- GetRange(int StartIndex, int EndIndex) :  Trả về 1 ArrayList bao gồm các phần tử từ vị trí StartIndex đến EndIndex trong ArrayList ban đầu.
- IndexOf(object Value) : Trả về vị trí đầu tiên xuất hiện đối tượng Value trong ArrayList. Nếu không tìm thấy sẽ trả về -1.
- Insert(int Index, object Value) : Chèn đối tượng Value vào vị trí Index trong ArrayList.
- InsertRange(int Index, ICollection ListObject) : Chèn danh sách phần tử ListObject vào vị trí Index trong ArrayList.
- LastIndexOf(object Value) :  Trả về vị trí xuất hiện cuối cùng của đối tượng Value trong ArrayList. Nếu không tìm thấy sẽ trả về -1.
- Remove(object Value) : Xoá đối tượng Value xuất hiện đầu tiên trong ArrayList.
- Reverse() : Đảo ngược tất cả phần tử trong ArrayList.
- Sort() : Sắp xếp các phần tử trong ArrayList theo thứ tự tăng dần.
- ToArray() : Trả về 1 mảng các object chứa các phần tử được sao chép từ ArrayList.

Sort ( IComparer comparer) 

Tham số truyền vào là 1 lớp có kế thừa từ interface IComparer .
Interface IComparer chứa 1 phương thức duy nhất là:
int Comparer (object x, object y).

Phương thức này sẽ trả về 3 giá trị:
Bé hơn 0 nếu x < y.
Lớn hơn 0 nếu x > y.
Bằng 0 nếu x = y.

- Lớp Người : 
public class Person
    {
        private string name;
        private int age;

        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        public int Age
        {
            get { return age; }
            set { age = value; }
        }

        public Person(string Name, int Age)
        {
            this.Name = Name;
            this.Age = Age;
        }
        public override string ToString()
        {
            return "Name: " + name + " | Age: " + age;
        }
    }

- Hàm IComparer trong Sort
 public class SortPersons : IComparer
    {
        public int Compare(object x, object y)
        {
            // Ép kiểu 2 object truyền vào về Person.
            Person p1 = x as Person;
            Person p2 = y as Person;

            /*
             * Vì có thể 2 object truyền vào không phải Person khi đó ta không thể so sánh được.
             * Trường hợp này tốt nhất ta nên ném ra lỗi để lập trình viên sửa chữa.
             * Chi tiết về exception sẽ được trình bày ở những bài học sau.
             */
            if (p1 == null || p2 == null)
            {
                throw new InvalidOperationException();
            }
            else
            {
                if (p1.Age > p2.Age)
                {
                    return 1;
                }
                else if (p1.Age == p2.Age)
                {
                    return 0;
                }
                else
                {
                    return -1;
                }
            }
        }
    }

- Cách Dùng :
// Tạo 1 danh sách kiểu ArrayList rỗng
ArrayList arrPersons = new ArrayList();

// Thêm 3 Person vào danh sách
arrPersons.Add(new Person("Nguyen Van A", 18));
arrPersons.Add(new Person("Nguyen Van B", 25));
arrPersons.Add(new Person("Nguyen Van C", 20));

// In thử danh sách Person ban đầu ra.
Console.WriteLine("Danh sach Person ban dau: ");
foreach (Person item in arrPersons)
{
    Console.WriteLine(item.ToString());
}

/* 
 * Thực hiện sắp xếp danh sách Person theo tiêu chí đã được định nghĩa 
 * trong phương thức Compare của lớp SortPerson (tuổi tăng dần).
*/
arrPersons.Sort(new SortPersons());

// In danh sách Person đã được sắp xếp ra màn hình.
Console.WriteLine();
Console.WriteLine("Danh sach Person da duoc sap xep theo tuoi tang dan: ");
foreach (Person item in arrPersons)
{
    Console.WriteLine(item.ToString());
}

27. HashTable trong C# 
- Là một Collections lưu trữ dữ liệu dưới dạng cặp Key - Value :
Key đại diện cho 1 khoá giống như chỉ số phần tử của mảng và Value chính là giá trị tương ứng của khoá đó.
Ta sẽ dử dụng Key để truy cập đến Value tương ứng.
Vì Key và Value đều là kiểu object nên ta có thể lưu trữ được mọi kiểu dữ liệu từ những kiểu cơ sở đến kiểu phức tạp (class).
Vì Hashtable là một lớp nên trước khi sử dụng ta cần khởi tạo vùng nhớ bằng toán tử new

using System.Collections;

// khởi tạo 1 Hashtable rỗng
Hashtable MyHash = new Hashtable(); 
// khởi tạo 1 Hashtable và chỉ định Capacity ban đầu là 5
Hashtable MyHash2 = new Hashtable(5); 
/*
 * Khởi tạo 1 Hashtable có kích thước bằng với MyHash2.
 * Sao chép toàn độ phần tử trong MyHash2 vào MyHash3.
 */
Hashtable MyHash3 = new Hashtable(MyHash2);

Thuộc tính :
- Count :  Trả về 1 số nguyên là số phần tử hiện có trong Hashtable.
- Keys : Trả về 1 danh sách chứa các Key trong Hashtable.
- Values : Trả về 1 danh sách chứa các Value trong Hashtable.

Phương thức :
- Add(object Key, object Value) :  Thêm 1 cặp Key - Value vào Hashtable.
- Clear() : Xoá tất cả các phần tử trong Hashtable.
- Clone() : Tạo 1 bản sao từ Hashtable hiện tại.
- ContainsKey(object Key) : Kiểm tra đối tượng Key có tồn tại trong Hashtable hay không.
- ContainsValue(object Value) : Kiểm tra đối tượng Value có tồn tại trong Hashtable hay không.
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong Hashtable sang mảng một chiều array từ vị trí Index của array.
Lưu ý: array phải là mảng các object hoặc mảng các DictionaryEntry.
- Remove(object Key) :  Xoá đối tượng có Key xuất hiện đầu tiên trong Hashtable.

Một số lưu ý về Hashtable : 
Mỗi một phần tử trong Hashtable (bao gồm 1 cặp Key - Value) được C# định nghĩa là 1 đối tượng có kiểu DictionaryEntry. 
Trong DictionaryEntry có 2 thuộc tính chính:
Key: trả về giá trị Key của phần tử hiện tại.
Value: trả về giá trị Value của phần tử hiện tại.

// Tạo một Hashtable đơn giản với 3 phần tử
            Hashtable hash = new Hashtable();
            hash.Add("K", "Kteam");
            hash.Add("H", "HowKteam");
            hash.Add("FE", "Free Education");

            /* 
             * Duyệt qua các phần tử trong Hashtable.
 * Vì mỗi phần tử là 1 DictionaryEntry nên ta chỉ định kiểu dữ liệu cho item là DictionaryEntry luôn.
             * Thử in ra màn hình cặp Key - Value của mỗi phần tử được duyệt.
             */
            foreach (DictionaryEntry item in hash)
            {
                Console.WriteLine(item.Key + "\t" + item.Value);   
            }

Truy xuất các phần tử trong Hashtable
Console.WriteLine(MyHash["One"]);

Ta nên cẩn thận khi truy xuất các phần tử trong Hashtable thông qua Key:
Nếu ta thực hiện lấy giá trị 1 phần tử trong Hashtable với Key không tồn tại thì sẽ ra giá trị null và không báo lỗi.
Nếu ta thực hiện gán giá trị cho 1 phần tử trong Hashtable tại vị trí Key không tồn tại thì Hashtable sẽ tự thêm 1 phần tử mới với Key và Value như trên. 
Điều này có thể làm phát sinh thêm các phần tử không mong muốn trong danh sách.

28. SortedList trong C# 
SortedList cũng là một Collections lưu trữ dữ liệu dưới dạng cặp Key - Value. 
Key đại diện cho 1 khoá giống như chỉ số phần tử của mảng và Value chính là giá trị tương ứng của khoá đó.
Là 1 Hashtable nhưng các giá trị được sắp xếp theo Key. 
Việc sắp xếp này được thực hiện một cách tự động mỗi khi thêm 1 phần tử mới vào SortedList.
Có thể truy xuất đến các phần tử trong SortedListthông qua Key(như Hashtable) hoặc thông qua chỉ số phần tử (như ArrayList).
SortedList chính là sự kết hợp giữa ArrayList với Hashtable .

using System.Collections;

// khởi tạo 1 SortedList rỗng
SortedList MySL = new SortedList(); 
// khởi tạo 1 SortedList và chỉ định Capacity ban đầu là 5
SortedList MySL2 = new SortedList(5); 
/*
 * Khởi tạo 1 SortedList có kích thước bằng với MySL2.
 * Sao chép toàn độ phần tử trong MySL2 vào MySL3.
 */
SortedList MySL3 = new SortedList(MySL2);
/*
 * Mình định nghĩa 1 lớp PersonComparer có thực thi 1 interface IComparer
 * Sau đó override lại phương thức Compare.
 * Sử dụng lớp trên để truyển vào constructor của SortedList.
 */
SortedList MySL4 = new SortedList(new PersonComparer());
/*
 * Tạo 1 SortedList mới và sao chép các phần tử từ MySL3 đồng thời sắp xếp các phần tử lại
 * theo cách sắp xếp được định nghĩa trong lớp PersonComparer.
 */
SortedList MySL5 = new SortedList(MySL3, new PersonComparer());

Vì SortedList là sự kết hợp giữa ArrayList và Hashtable nên nó sẽ mang các thuộc tính, phương thức giống 2 Collections trên và một vài phương thức mới.
Thuộc Tính : Count, Capacity, Keys, Values

Phương Thức :
- Add(object Key, object Value)
- Clear(),  Clone(), ContainsKey(object Key), ContainsValue(object Value)
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong SortedList sang mảng một chiều array từ vị trí Index của array.
Lưu ý: array phải là mảng các object hoặc mảng các DictionaryEntry.
- GetByIndex(int Index) : Trả về giá trị Value tại vị trí Index trong SortedList.
- GetKey(int Index) : Trả về giá trị Key tại vị trí Index trong SortedList.
- GetKeyList() :  Trả về 1 List các Key trong SortedList. 
- GetValueList() : Trả về 1 List các Value trong SortedList.
- IndexOfKey(object Key) : Trả về 1 số nguyên là chỉ số phần tử của 1 Key trong SortedList.
- Remove(object Key) : Xoá đối tượng có Key xuất hiện đầu tiên trong SortedList.
- RemoveAt(int Index) : Xoá đối tượng tại vị trí Index trong SortedList.
- SetByIndex(int Index, object Value) : Gán giá trị Value mới tại vị trí Index trong SortedList.

Một số lưu ý :
Nếu bạn muốn các giá trị Key là các đối tượng thuộc 1 lớp nào đó thì bạn phải định nghĩa cách so sánh đối tượng đó. 
Nếu không chương trình sẽ báo lỗi vì nó không biết phải sắp xếp các Key này như thế nào. 
// Lỗi do chưa định nghĩa cách so sánh cho Person
SortedList MySL6 = new SortedList();
MySL6.Add(new Person("HowKteam", 20), 10);
MySL6.Add(new Person("Kteam", 2), 15);
// Để khắc phục điều này ta có thể định nghĩa 1 lớp thực thi interface IComparer và định nghĩa cách sắp xếp trong hàm Comparer(Bên trên)
// tạo 1 SortedList và truyền vào cách sắp xếp các Key trong SortedList này.
            SortedList MySL6 = new SortedList(new PersonComparer());
// Nên override lại cả phương thức toString để việc in ra Key và Value không bị lỗi:
Ta thử override phương thức ToString trong lớp Person:
public override string ToString()
{
     return Name + " : " + Age;
}

29. Stack trong C#
Stack là một Collections đại diện cho một danh sách hoạt động theo nguyên lý LIFO

using System.Collections;
// khởi tạo 1 Stack rỗng
Stack MyStack = new Stack();
// khởi tạo 1 Stack và chỉ định sức chứa ban đầu là 5
Stack MyStack = new Stack(5); 
// khởi tạo 1 mảng bất kỳ
ArrayList MyArray = new ArrayList();
MyArray.Add(5);
MyArray.Add(9);
MyArray.Add(10);
// Khởi tạo 1 Stack và sao chép giá trị của các phần tử từ MyArray vào Stack.
Stack MyStack3 = new Stack(MyArray);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong Stack.
Phương Thức : 
- Clear(),Clone(),  Contains (object Value), Contains (object Value), CopyTo(Array array, int Index)
- Peek() : Trả về giá trị của đối tượng tại vị trí trên cùng trong Stack (phần tử thêm vào cuối cùng) nhưng không xoá phần tử khỏi Stack.
- Pop() :  Trả về giá trị của đối tượng tại vị trí trên cùng trong Stack(phần tử thêm vào cuối cùng) đồng thời xoá phần tử khỏi Stack.
- Push(object Value) : Thêm một phần tử có giá trị Value vào vị trí trên cùng trong Stack.
- ToArray() : Tạo ra 1 mảng các object chứa tất cả các phần tử trong Stack và trả về mảng đó.

30. Queue trong C#
- là một cấu trúc dữ liệu hoạt động theo nguyên lý FIFO (First In First Out). 

using System.Collections;

// khởi tạo 1 Queue rỗng
Queue MyQueue = new Queue(); 
// khởi tạo 1 Queue và chỉ định sức chứa ban đầu là 5
Queue MyQueue2 = new Queue(5); 
// khởi tạo 1 mảng bất kỳ
ArrayList MyArray = new ArrayList();
MyArray.Add(5);
MyArray.Add(9);
MyArray.Add(10);
// Khởi tạo 1 Queue và sao chép giá trị của các phần tử từ MyArray vào Queue.
Queue MyQueue3 = new Queue(MyArray);

Thuộc Tính : 
- Count : Trả về 1 số nguyên là số phần tử hiện có trong Queue .

Phương Thức :
- Clear(), Clone(), Contains (object Value), 
- CopyTo(Array array, int Index) : Thực hiện sao chép tất cả phần tử trong Queue sang mảng một chiều array từ vị trí Index của array.
- Enqueue () : Trả về giá trị của đối tượng tại vị trí đầu trong Queue (phần tử thêm vào đầu tiên) nhưng không xoá phần tử khỏi Queue.
- Dequeue() : Trả về giá trị của đối tượng tại vị trí đầu trong Queue(phần tử thêm vào đầu tiên)đồng thời xoá phần tử khỏi Queue.
- Push(object Value) :  Thêm một phần tử có giá trị Value vào đầu Queue.
- ToArray() : Tạo ra 1 mảng các object  chứa tất cả các phần tử trong Queue và trả về mảng đó.

